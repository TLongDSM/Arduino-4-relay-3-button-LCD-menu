/*
Â * Dá»° ÃN: Há»† THá»NG ÄIá»€U KHIá»‚N 4 RELAY Sá»¬ Dá»¤NG Háº¸N GIá»œ, CHU Ká»² VÃ€ MENU LCD 16X2 I2C
Â * PHIÃŠN Báº¢N: 137.8 (Fix lá»—i biÃªn dá»‹ch, LCD Sleep/Wake-up, vÃ  Lá»—i Logic Alert/Cycle Limit)
Â *
Â * CÃC THAY Äá»”I VÃ€ Tá»I Æ¯U HÃ“A ÄÃƒ ÃP Dá»¤NG:
Â * 1. FIX Lá»–I LOGIC: Sá»­a lá»—i Ã©p kiá»ƒu chuá»—i RAM/PROGMEM trong hÃ m showAlert (handleButtonSelect_Hold).
Â * 2. FIX LOGIC CYCLE LIMIT: ÄÆ¡n giáº£n hÃ³a logic táº£i cycle limit tá»« EEPROM Ä‘á»ƒ giá»›i háº¡n chÃ­nh xÃ¡c (max 99 hoáº·c 9999=INF).
Â * 3. ThÃªm LCD Sleep/Wake-up: Táº¯t Ä‘Ã¨n ná»n LCD sau 30 giÃ¢y khÃ´ng hoáº¡t Ä‘á»™ng.
Â * 4. Tá»‘i Æ°u hÃ³a: Loáº¡i bá» hoÃ n toÃ n logic vÃ  biáº¿n Máº­t kháº©u, Fast Step.
Â *
Â * Cáº¤U HÃŒNH Máº¶C Äá»ŠNH: R1/R2=MAN/ON, R3=AUT (11:00-21:00), R4=CYC (22:00-22:10, 5m On/Off, Limit=99).
Â */

// 1. THÆ¯ VIá»†N
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <RTClib.h>
#include <EEPROM.h>
#include <avr/wdt.h>
#include <stddef.h>

// 2. Äá»ŠNH NGHÄ¨A CÃC Háº°NG Sá» Cáº¤U HÃŒNH
const int LCD_I2C_ADDR = 0x27;

// *** CHÃ‚N NÃšT NHáº¤N ***
const uint8_t BUTTON_UP_PIN = 13;
const uint8_t BUTTON_SELECT_PIN = 12;
const uint8_t BUTTON_DOWN_PIN = 11;

// *** CHÃ‚N RELAY ***
const uint8_t relayPins[4] = { 10, 9, 8, 7 };

// *** CHÃ‚N Cáº¢M BIáº¾N (DIGITAL) ***
const uint8_t SENSOR_PINS[4] = { 6, 5, 4, 3 };

// *** Cáº¤U HÃŒNH CÃC Háº°NG Sá» CHUNG ***
const uint8_t NUM_RELAYS = 4;
const uint8_t NUM_TIMERS_PER_RELAY = 4;
const unsigned long DEBOUNCING_TIME = 150;
const unsigned long AUTO_RETURN_DELAY = 10000;
const unsigned long EEPROM_SAVE_DELAY = 3000;
const char EEPROM_MAGIC_BYTE = 'D';
const unsigned long CYCLE_SAVE_INTERVAL = 900000;Â  // 15 phÃºt
const uint16_t CYCLE_COUNT_THRESHOLD = 10;
const unsigned long RTC_EXIT_HOLD_TIME = 3000;
const unsigned long CYCLE_RESET_HOLD_TIME = 2000;
const unsigned long ALERT_DISPLAY_TIME = 1500;
const unsigned long QUICK_SELECT_TIMEOUT = 3000;
const unsigned long OVERRIDE_HOLD_TIME = 1500;
const unsigned long CYCLE_RESUME_SAVE_INTERVAL = 900000;Â  // 15 phÃºt (900 giÃ¢y) - Tá»‘i Æ°u hÃ³a EEPROM

// === THÃ”NG Sá» LCD WAKE-UP/SLEEP ===
const unsigned long LCD_SLEEP_DELAY = 30000;Â  // 30 giÃ¢y
// =====================================

// === GIá»šI Háº N Tá»C Äá»˜ Cáº¬P NHáº¬T LCD (Cho Menu) ===
const unsigned long LCD_UPDATE_INTERVAL = 250;
unsigned long lastLcdUpdate = 0;
// =====================================


// 3. KHá»I Táº O Äá»I TÆ¯á»¢NG PHáº¦N Cá»¨NG
LiquidCrystal_I2C lcd(LCD_I2C_ADDR, 16, 2);
RTC_DS1307 RTC;

// 4. Äá»ŠNH NGHÄ¨A ENUMS VÃ€ Cáº¤U TRÃšC Dá»® LIá»†U
enum MenuState : uint8_t {
Â  MENU_HOME = 0,
Â  MENU_RELAY_SETTINGS = 2,
Â  MENU_RTC_EDIT = 4,
Â  MENU_RTC_MAIN_MENU = 6,
Â  MENU_SAVE_PROMPT = 9,
Â  MENU_ALERT = 10
};
enum RelayMode : uint8_t {
Â  MODE_MAN = 0,
Â  MODE_AUT = 1,
Â  MODE_CYC = 2
};
enum SensorLogic : uint8_t {
Â  SENSOR_LOGIC_LOW_ACTIVE = 0,
Â  SENSOR_LOGIC_HIGH_ACTIVE = 1
};
enum RelayMenuOption : uint8_t {
Â  RELAY_BACK = 0,
Â  RELAY_MODE = 1,
Â  RELAY_STATUS_OR_TIMER1 = 2,
Â  RELAY_TIMER2 = 3,
Â  RELAY_TIMER3 = 4,
Â  RELAY_TIMER4 = 5,
Â  RELAY_SENSOR_GATE = 6,
Â  RELAY_SENSOR_LOGIC = 7
};
enum TimerMenuOption : uint8_t {
Â  TIMER_BACK = 0,
Â  TIMER_MODE = 1,
Â  TIMER_DOW_SETTING = 2,
Â  TIMER_ON_TIME = 3,
Â  TIMER_OFF_TIME = 4,
Â  TIMER_CYCLE_ON_DUR = 5,
Â  TIMER_CYCLE_OFF_DUR = 6,
Â  TIMER_CYCLE_LIMIT = 7,
Â  TIMER_RESET_COUNT = 8
};
enum RtcEditStep : uint8_t {
Â  RTC_EDIT_HH,
Â  RTC_EDIT_MM,
Â  RTC_EDIT_DD,
Â  RTC_EDIT_MO,
Â  RTC_EDIT_YY,
Â  RTC_EDIT_SAVE,
Â  RTC_EDIT_CANCEL,
Â  RTC_EDIT_BACK
};
enum SettingStep : uint8_t {
Â  STEP_HH_OR_VALUE = 0,
Â  STEP_MM = 1,
Â  STEP_DONE = 3,
Â  STEP_NAV_TIMER = 4,
};
enum RtcMenuOption : uint8_t {
Â  RTC_MENU_TIME,
Â  RTC_MENU_DATE,
Â  RTC_MENU_BACK
};

typedef struct {
Â  uint8_t hour;
Â  uint8_t minute;
} TimeOfDay_MinOnly;

typedef struct {
Â  uint8_t hour;
Â  uint8_t minute;
Â  uint8_t second;
} TimeOfDay_Full;

typedef struct {
Â  uint8_t minute;
Â  uint8_t second;
} TimeDuration;

typedef struct {
Â  uint8_t mode;
Â  TimerMenuOption selectedOption;
Â  SettingStep setting_step;
Â  TimeOfDay_MinOnly time_on;
Â  TimeOfDay_MinOnly time_off;
Â  TimeDuration cycle_duration_on;
Â  TimeDuration cycle_duration_off;
Â  uint16_t cycle_limit;
Â  uint16_t cycle_count;
Â  uint8_t dow_mask;

Â  // Cache vÃ  Logic
Â  uint32_t cached_on_sec;
Â  uint32_t cached_off_sec;
Â  uint32_t cached_time_on_sec;
Â  uint32_t cached_time_off_sec;
Â  bool cycle_is_on;
Â  uint32_t cycle_last_state_change_time_seconds;
} TimerData;

typedef struct {
Â  RelayMode mode;
Â  uint8_t status;
Â  RelayMenuOption selectedOption;
Â  bool sensor_gate_enabled;
Â  SensorLogic sensor_logic;
} RelayData;

typedef struct {
Â  MenuState currentState;
Â  uint8_t selectedIndex;
} Navigation;

typedef struct {
Â  uint8_t mode;
Â  TimeOfDay_MinOnly time_on;
Â  TimeOfDay_MinOnly time_off;
Â  TimeDuration cycle_duration_on;
Â  TimeDuration cycle_duration_off;
Â  uint16_t cycle_limit;
Â  uint16_t cycle_count;
Â  uint8_t dow_mask;
Â  uint8_t cycle_is_on_state;
Â  uint32_t cycle_start_time_sec;
} EepromTimerData;

typedef struct {
Â  RelayMode relay_mode[4];
Â  uint8_t relay_status[4];
Â  EepromTimerData timers[4][4];
Â  bool sensor_gate_enabled[4];
Â  SensorLogic sensor_logic[4];
Â  char magic_byte;
} EepromData;


// 5. KHAI BÃO BIáº¾N TOÃ€N Cá»¤C VÃ€ Háº°NG Sá»
DateTime now;
uint32_t currentTimeSeconds;
TimeOfDay_Full currentTime;
Navigation nav;
RelayData relays[NUM_RELAYS];
TimerData timers[NUM_RELAYS][NUM_TIMERS_PER_RELAY];
EepromData eepromData;
unsigned long lastActionTime = 0;
bool settings_changed = false;
unsigned long lastSettingsChangeTime = 0;
uint8_t currentRelayOutputState[4] = { LOW };
uint8_t lastSecond = 60;
uint8_t lastMinute = 60;
uint8_t lastRelayState[4] = { 2 };
MenuState currentDisplayedMenu = MENU_HOME;
bool rtc_initialized = false;
DateTime rtc_temp_time;
bool needsDisplayUpdate = true;
bool cycle_count_changed = false;
unsigned long lastCycleCountSaveTime = 0;
unsigned long lastCycleResumeSaveTime = 0;

uint16_t cycleCountBuffer[NUM_RELAYS][NUM_TIMERS_PER_RELAY] = { 0 };

RtcEditStep rtcEditStep;
RtcMenuOption rtcMenuOption = RTC_MENU_TIME;
bool buttonClickProcessed = false;
uint8_t dow_cursor[NUM_RELAYS][NUM_TIMERS_PER_RELAY] = { 0 };

unsigned long pressSelectStartTime = 0;
bool isHoldingSelect = false;
unsigned long selectHoldStartTime = 0;

volatile bool buttonUpFlag = false;
volatile bool buttonDownFlag = false;
volatile bool buttonSelectFlag = false;
volatile unsigned long interruptEndTime = 0;
volatile uint8_t lastButtonState[3] = { HIGH, HIGH, HIGH };Â  // UP, SELECT, DOWN

// **Má»šI: Tráº¡ng thÃ¡i LCD**
bool lcd_is_awake = true;

const char RELAY_ON_CHAR = '*';
const char RELAY_OFF_CHAR = '-';
const char SENSOR_ACTIVE_CHAR = '!';
const char SENSOR_INACTIVE_CHAR = '-';

// Biáº¿n cho UX/Tá»‘i Æ°u hiá»ƒn thá»‹ DÃ²ng 1
uint8_t lastDay = 32;


// DÃ¹ng PROGMEM cho cÃ¡c chuá»—i hiá»ƒn thá»‹ dÃ i
const char MSG_RTC_ERROR[] PROGMEM = "RTC ERROR!";
const char MSG_SAVE_PROCESS[] PROGMEM = "DANG LUU.........";
const char MSG_EEPROM_RESET_OK[] PROGMEM = "EEPROM RESET OK!";
const char MSG_COUNT_RESET_OK[] PROGMEM = "COUNT RESET OK!";
const char MSG_ON_OFF_ERROR[] PROGMEM = "ON=OFF! Auto OFF";
const char STR_ON[] PROGMEM = "ON";
const char STR_OFF[] PROGMEM = "OFF";
const char MSG_TIMER_ACTIVE[] PROGMEM = "TIMER IS ACTIVE!";
const char MSG_OVERRIDE_OK[] PROGMEM = "OVERRIDE OK!";
const char MSG_SENSOR_DISABLED[] PROGMEM = "SEN OFF";

const __FlashStringHelper* currentAlertMessage = nullptr;
char currentAlertMessageRam[16] = { 0 };Â  // Buffer cho thÃ´ng bÃ¡o Ä‘á»™ng (RAM)
unsigned long alertStartTime = 0;
MenuState stateBeforeAlert;

uint8_t currentDayMask = 0;
uint8_t previousDayMask = 0;
int8_t currentDayOfWeek = -1;

// 6. KHAI BÃO NGUYÃŠN MáºªU HÃ€M
void handleButtons();
void updateDisplay();
void handleBackgroundTasks(unsigned long currentMillis);
void wakeLcd();Â  // **HÃ m Ä‘Ã¡nh thá»©c LCD**

void displayRelayMenu(uint8_t r);
void displayTimerMenu(uint8_t r);
void displayRtcMainMenu();

void displayRtcEdit_Dynamic();
void updateRtcEdit_Cursor();
void navigateRtcEdit(bool isUp, uint16_t step);
void selectRtcEdit();

void handleButtonUp(unsigned long currentMillis);
void handleButtonDown(unsigned long currentMillis);
void handleButtonSelect_Click();
void handleButtonSelect_Hold(bool checkCycleReset);

void navigateRelaySettings(uint8_t r, bool isUp);
void navigateTimerMenu(uint8_t r, uint8_t t, bool isUp);
void navigateSavePrompt(bool isUp);
void selectSavePrompt();

void selectRelaySettings(uint8_t r);
// Sá»¬A Lá»–I TYPO VÃ€ THIáº¾U THAM Sá»:
void selectTimerSettings(uint8_t r, uint8_t t);

void runRelay(uint8_t r, uint32_t currentTimeSeconds);

void saveSettings();
void updateCycleCountsInEeprom();
void updateRelayStatusInEeprom();
void updateCycleResumeStateInEeprom(uint8_t r, uint8_t t);
void loadSettings();
void resetSettings();

void printTime(uint8_t hour, uint8_t minute, uint8_t second, bool includeSeconds);
void printCycleTime(uint8_t minute, uint8_t second);
void printPaddedLimit(uint16_t limit, bool includeSeconds);
const __FlashStringHelper* getDowMenuStr(uint8_t index);
void showAlert(const __FlashStringHelper* message);Â  // Cho chuá»—i PROGMEM
void showAlertRam(const char* message);Â  Â  Â  Â  Â  Â  Â  // **Má»šI: Cho chuá»—i RAM (Ä‘á»™ng)**

void navigateSettingValue(uint8_t r, uint8_t t, bool isUp, uint16_t step);

void updateTimeValue(uint8_t r, uint8_t t, bool isHour, bool isUp, uint8_t step);
void updateDurationValue(uint8_t r, uint8_t t, bool isMinute, bool isUp, uint16_t step);
void updateCountValue(uint8_t r, uint8_t t, bool isUp, uint16_t step);
void updateCursorPos(uint8_t r, uint8_t t);
const __FlashStringHelper* getDayStr(uint8_t dayOfWeek);
const __FlashStringHelper* getModeStr(RelayMode mode);
bool isSensorConditionMet(uint8_t r);

void updateHomeTime(bool forceFullDisplayUpdate);


// 7. HÃ€M SETUP()
void setup() {
Â  lcd.init();
Â  lcd.backlight();
Â  lcd_is_awake = true;Â  // Khá»Ÿi táº¡o LCD á»Ÿ tráº¡ng thÃ¡i báº­t

Â  for (uint8_t i = 0; i < NUM_RELAYS; i++) {
Â  Â  pinMode(relayPins[i], OUTPUT);
Â  Â  digitalWrite(relayPins[i], LOW);
Â  Â  lastRelayState[i] = LOW;

Â  Â  pinMode(SENSOR_PINS[i], INPUT_PULLUP);
Â  }
Â  Wire.begin();

Â  if (!RTC.begin()) {
Â  Â  rtc_initialized = false;
Â  Â  lcd.clear();
Â  Â  lcd.setCursor(0, 0);
Â  Â  lcd.print((const __FlashStringHelper*)MSG_RTC_ERROR);
Â  Â  lcd.setCursor(0, 1);
Â  Â  lcd.print(F("SAFE MODE ON"));
Â  } else {
Â  Â  if (!RTC.isrunning()) {
Â  Â  Â  lcd.clear();
Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  lcd.print(F("RTC NOT RUNNING!"));
Â  Â  Â  lcd.setCursor(0, 1);
Â  Â  Â  lcd.print(F("PLEASE SET TIME!"));

Â  Â  Â  // ğŸ’¡ HÃƒY Bá» BÃŒNH LUáº¬N DÃ’NG DÆ¯á»šI ÄÃ‚Y KHI Báº N Táº¢I LÃŠN Láº¦N Äáº¦U
Â  Â  Â  // Äá»‚ Äáº¶T RTC Báº°NG THá»œI GIAN Cá»¦A MÃY TÃNH HIá»†N Táº I!
Â  Â  Â  // SAU ÄÃ“, BÃŒNH LUáº¬N NÃ“ Láº I TRÆ¯á»šC KHI Táº¢I LÃŠN Báº¤T Ká»² Láº¦N NÃ€O KHÃC.
Â  Â  Â  // RTC.adjust(DateTime(F(__DATE__), F(__TIME__)));

Â  Â  Â  delay(1500);
Â  Â  Â  lcd.clear();
Â  Â  }
Â  Â  rtc_initialized = true;
Â  Â  now = RTC.now();
Â  }

Â  pinMode(BUTTON_UP_PIN, INPUT_PULLUP);
Â  pinMode(BUTTON_SELECT_PIN, INPUT_PULLUP);
Â  pinMode(BUTTON_DOWN_PIN, INPUT_PULLUP);

Â  // Kiá»ƒm tra tá»• há»£p phÃ­m reset EEPROM
Â  if (digitalRead(BUTTON_UP_PIN) == LOW && digitalRead(BUTTON_DOWN_PIN) == LOW) {
Â  Â  lcd.clear();
Â  Â  lcd.setCursor(0, 0);
Â  Â  lcd.print(F("HOLD UP+DW RST"));
Â  Â  lcd.setCursor(0, 1);
Â  Â  lcd.print(F("EEPROM (3s)..."));

Â  Â  wdt_enable(WDTO_4S);
Â  Â  delay(3000);
Â  Â  wdt_reset();

Â  Â  if (digitalRead(BUTTON_UP_PIN) == LOW && digitalRead(BUTTON_DOWN_PIN) == LOW) {
Â  Â  Â  resetSettings();
Â  Â  Â  lcd.clear();
Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  lcd.print((const __FlashStringHelper*)MSG_EEPROM_RESET_OK);
Â  Â  Â  delay(1500);
Â  Â  Â  wdt_reset();
Â  Â  }
Â  Â  wdt_disable();
Â  }

Â  nav.selectedIndex = 0;
Â  nav.currentState = MENU_HOME;
Â  currentDisplayedMenu = MENU_HOME;
Â  lastActionTime = millis();Â  // Khá»Ÿi táº¡o lastActionTime Ä‘á»ƒ LCD khÃ´ng ngá»§ ngay láº­p tá»©c
Â  loadSettings();

Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  Â  cycleCountBuffer[r][t] = timers[r][t].cycle_count;
Â  Â  }
Â  }

Â  lcd.clear();
Â  lcd.setCursor(0, 0);
Â  lcd.print(F(" I LOVE DUTHY"));
Â  lcd.setCursor(0, 1);
Â  lcd.print(F(" SYSTEM LOADING"));

Â  delay(3000);

Â  lcd.clear();
Â  wdt_enable(WDTO_2S);
}

// 8. HÃ€M LOOP() CHÃNH
void loop() {
Â  wdt_reset();

Â  unsigned long currentMillis = millis();

Â  // === POLLING ÄÆ N GIáº¢N VÃ€ GHI ÄÃˆ Cá»œ ===
Â  if (digitalRead(BUTTON_UP_PIN) == LOW) buttonUpFlag = true;
Â  if (digitalRead(BUTTON_SELECT_PIN) == LOW) buttonSelectFlag = true;
Â  if (digitalRead(BUTTON_DOWN_PIN) == LOW) buttonDownFlag = true;

Â  handleButtons();
Â  // ===============================================

Â  if (rtc_initialized) {
Â  Â  if (currentTime.second != RTC.now().second()) {
Â  Â  Â  now = RTC.now();

Â  Â  Â  currentTime.hour = now.hour();
Â  Â  Â  currentTime.minute = now.minute();
Â  Â  Â  currentTime.second = now.second();

Â  Â  Â  currentTimeSeconds = (uint32_t)currentTime.hour * 3600 + (uint32_t)currentTime.minute * 60 + currentTime.second;

Â  Â  Â  currentDayOfWeek = now.dayOfTheWeek();

Â  Â  Â  uint8_t dowBit;
Â  Â  Â  if (currentDayOfWeek == 0) dowBit = 6;
Â  Â  Â  else dowBit = currentDayOfWeek - 1;
Â  Â  Â  currentDayMask = 1 << dowBit;

Â  Â  Â  uint8_t prevDowBit;
Â  Â  Â  uint8_t prevDayOfWeek = (currentDayOfWeek == 0) ? 6 : currentDayOfWeek - 1;
Â  Â  Â  if (prevDayOfWeek == 0) prevDowBit = 6;
Â  Â  Â  else prevDowBit = prevDayOfWeek - 1;
Â  Â  Â  previousDayMask = 1 << prevDowBit;
Â  Â  }
Â  } else {
Â  Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  Â  if (relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  relays[r].mode = MODE_MAN;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  Â  lastSettingsChangeTime = currentMillis;
Â  Â  Â  }
Â  Â  }
Â  Â  currentTime.hour = 0;
Â  Â  currentTime.minute = 0;
Â  Â  currentTime.second = 0;
Â  Â  currentTimeSeconds = 0;
Â  }

Â  handleBackgroundTasks(currentMillis);

Â  for (uint8_t i = 0; i < NUM_RELAYS; i++) {
Â  Â  runRelay(i, currentTimeSeconds);
Â  }
Â  updateDisplay();
}

// **HÃ€M ÄÃNH THá»¨C LCD**
void wakeLcd() {
Â  if (!lcd_is_awake) {
Â  Â  lcd.backlight();
Â  Â  // Báº¯t buá»™c váº½ láº¡i mÃ n hÃ¬nh khi Ä‘Ã¡nh thá»©c
Â  Â  currentDisplayedMenu = (MenuState)0xFF;
Â  Â  needsDisplayUpdate = true;
Â  Â  lcd_is_awake = true;
Â  }
Â  // Cáº­p nháº­t thá»i gian hÃ nh Ä‘á»™ng cuá»‘i cÃ¹ng
Â  lastActionTime = millis();
}

// 9. HÃ€M TÃC Vá»¤ Ná»€N & HIá»‚N THá»Š
void handleBackgroundTasks(unsigned long currentMillis) {

Â  // **LOGIC LCD SLEEP/WAKE-UP**
Â  if (lcd_is_awake && nav.currentState == MENU_HOME && (currentMillis - lastActionTime >= LCD_SLEEP_DELAY)) {
Â  Â  lcd.noBacklight();
Â  Â  lcd_is_awake = false;
Â  Â  // KhÃ´ng cáº§n xá»­ lÃ½ cÃ¡c tÃ¡c vá»¥ ná»n khÃ¡c náº¿u LCD Ä‘ang ngá»§.
Â  Â  return;
Â  }
Â  // Náº¿u LCD Ä‘ang ngá»§, chá»‰ thá»±c hiá»‡n WDT reset vÃ  kiá»ƒm tra rtc/relay
Â  if (!lcd_is_awake && (currentTime.second != lastSecond)) return;Â  // Chá»‰ cháº¡y background náº¿u cÃ³ thá»i gian thay Ä‘á»•i


Â  if (nav.currentState == MENU_ALERT) {
Â  Â  if ((currentAlertMessage != nullptr || currentAlertMessageRam[0] != 0) && currentMillis - alertStartTime >= ALERT_DISPLAY_TIME) {
Â  Â  Â  currentAlertMessage = nullptr;
Â  Â  Â  currentAlertMessageRam[0] = 0;
Â  Â  Â  MenuState returnState = stateBeforeAlert;
Â  Â  Â  nav.currentState = returnState;
Â  Â  Â  lastActionTime = currentMillis;
Â  Â  Â  needsDisplayUpdate = true;
Â  Â  Â  lcd.noCursor();
Â  Â  Â  lcd.noBlink();
Â  Â  }
Â  Â  return;
Â  }

Â  bool isRtcMenu = (nav.currentState == MENU_RTC_EDIT);
Â  bool isEditingTimer = false;
Â  if (nav.currentState == MENU_RELAY_SETTINGS) {
Â  Â  uint8_t r = nav.selectedIndex;
Â  Â  RelayMenuOption selected = relays[r].selectedOption;
Â  Â  if (selected >= RELAY_STATUS_OR_TIMER1 && selected <= RELAY_TIMER4) {
Â  Â  Â  uint8_t t = selected - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  if (timers[r][t].setting_step == STEP_HH_OR_VALUE || timers[r][t].setting_step == STEP_MM || (timers[r][t].selectedOption == TIMER_DOW_SETTING && timers[r][t].setting_step != STEP_NAV_TIMER)) {
Â  Â  Â  Â  isEditingTimer = true;
Â  Â  Â  }
Â  Â  }
Â  }

Â  // Auto-return logic
Â  if (nav.currentState != MENU_HOME && (currentMillis - lastActionTime >= AUTO_RETURN_DELAY) && nav.currentState != MENU_SAVE_PROMPT && !isRtcMenu && !isEditingTimer && nav.currentState != MENU_RTC_MAIN_MENU) {
Â  Â  nav.currentState = MENU_HOME;
Â  Â  needsDisplayUpdate = true;
Â  Â  nav.selectedIndex = 0;
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  }

Â  // Logic lÆ°u cáº¥u hÃ¬nh cÃ i Ä‘áº·t (EEPROM_SAVE_DELAY)
Â  if (settings_changed && (currentMillis - lastSettingsChangeTime >= EEPROM_SAVE_DELAY) && nav.currentState == MENU_HOME) {
Â  Â  showAlert((const __FlashStringHelper*)MSG_SAVE_PROCESS);
Â  Â  saveSettings();
Â  Â  settings_changed = false;
Â  Â  needsDisplayUpdate = true;
Â  }

Â  // LOGIC LÆ¯U CYCLE COUNT
Â  bool timeToSave = (currentMillis - lastCycleCountSaveTime > CYCLE_SAVE_INTERVAL);
Â  if (cycle_count_changed && (timeToSave || nav.currentState == MENU_HOME)) {
Â  Â  updateCycleCountsInEeprom();
Â  Â  cycle_count_changed = false;
Â  Â  lastCycleCountSaveTime = currentMillis;
Â  }

Â  // LOGIC LÆ¯U TRáº NG THÃI CHU Ká»² (POWER-LOSS RESUME)
Â  if (currentMillis - lastCycleResumeSaveTime >= CYCLE_RESUME_SAVE_INTERVAL) {
Â  Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  Â  if (relays[r].mode == MODE_CYC) {
Â  Â  Â  Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  Â  Â  Â  if (timers[r][t].cycle_last_state_change_time_seconds != 0 || (timers[r][t].mode == 1 && timers[r][t].cycle_count >= timers[r][t].cycle_limit && timers[r][t].cycle_limit != 9999)) {
Â  Â  Â  Â  Â  Â  updateCycleResumeStateInEeprom(r, t);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  Â  lastCycleResumeSaveTime = currentMillis;
Â  }
}

// 10. HÃ€M HIá»‚N THá»Š (DISPLAY)
void updateHomeRelayStatus() {
Â  if (!lcd_is_awake) return;Â  // KhÃ´ng váº½ náº¿u LCD Ä‘ang ngá»§

Â  if (rtc_initialized) {
Â  Â  // Vá»‹ trÃ­ Status Relay (DÃ²ng 0, kÃ½ tá»± 12)
Â  Â  lcd.setCursor(12, 0);
Â  Â  for (uint8_t i = 0; i < NUM_RELAYS; i++) {
Â  Â  Â  lcd.print(currentRelayOutputState[i] == HIGH ? RELAY_ON_CHAR : RELAY_OFF_CHAR);
Â  Â  Â  lastRelayState[i] = currentRelayOutputState[i];
Â  Â  }

Â  Â  bool isRtcSelected = nav.selectedIndex == NUM_RELAYS;
Â  Â  bool showQuickSelect = (millis() - lastActionTime < QUICK_SELECT_TIMEOUT) && (lastActionTime != 0);

Â  Â  lcd.setCursor(0, 1);

Â  Â  if (isRtcSelected) {
Â  Â  Â  lcd.print(F("> RTC SettingÂ  Â  Â  Â "));
Â  Â  Â  lastDay = 32;
Â  Â  } else if (showQuickSelect) {
Â  Â  Â  uint8_t r = nav.selectedIndex;
Â  Â  Â  RelayData currentRelay = relays[r];

Â  Â  Â  // >R[#]:MODE[*][!]
Â  Â  Â  lcd.print(F(">R"));
Â  Â  Â  lcd.print(r + 1);
Â  Â  Â  lcd.print(F(":"));
Â  Â  Â  lcd.print(getModeStr(currentRelay.mode));

Â  Â  Â  lcd.print(F("["));
Â  Â  Â  lcd.print(currentRelayOutputState[r] == HIGH ? RELAY_ON_CHAR : RELAY_OFF_CHAR);
Â  Â  Â  lcd.print(F("]["));
Â  Â  Â  if (currentRelay.sensor_gate_enabled) {
Â  Â  Â  Â  lcd.print(isSensorConditionMet(r) ? SENSOR_ACTIVE_CHAR : SENSOR_INACTIVE_CHAR);
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(SENSOR_INACTIVE_CHAR);
Â  Â  Â  }
Â  Â  Â  lcd.print(F("]Â  Â  Â  Â  Â  "));
Â  Â  Â  lastDay = 32;
Â  Â  } else {
Â  Â  Â  if (now.day() != lastDay || needsDisplayUpdate) {
Â  Â  Â  Â  lcd.setCursor(0, 1);
Â  Â  Â  Â  lcd.print(getDayStr(now.dayOfTheWeek()));
Â  Â  Â  Â  lcd.print(F(" "));
Â  Â  Â  Â  if (now.day() < 10) lcd.print('0');
Â  Â  Â  Â  lcd.print(now.day());
Â  Â  Â  Â  lcd.print(F("/"));
Â  Â  Â  Â  if (now.month() < 10) lcd.print('0');
Â  Â  Â  Â  lcd.print(now.month());
Â  Â  Â  Â  lcd.print(F("/"));
Â  Â  Â  Â  lcd.print(now.year());

Â  Â  Â  Â  lastDay = now.day();
Â  Â  Â  }

Â  Â  Â  lcd.setCursor(15, 1);
Â  Â  Â  if (settings_changed) {
Â  Â  Â  Â  lcd.print(RELAY_ON_CHAR);
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F(" "));
Â  Â  Â  }
Â  Â  }

Â  } else {
Â  Â  lcd.setCursor(0, 1);
Â  Â  lcd.print(F("SAFE MODEÂ  Â  Â  Â  Â  Â "));
Â  }
}

// **LOGIC Tá»I Æ¯U HIá»‚N THá»Š THá»œI GIAN (ÄÃ£ Sá»­a Lá»—i Dáº¥u Hai Cháº¥m vÃ  xÃ³a chá»¯ thá»«a)**
void updateHomeTime(bool forceFullDisplayUpdate) {
Â  if (!lcd_is_awake) return;Â  // KhÃ´ng váº½ náº¿u LCD Ä‘ang ngá»§

Â  if (!rtc_initialized) {
Â  Â  if (forceFullDisplayUpdate) {
Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  lcd.print(F("SAFE MODE --:--:-- "));
Â  Â  Â  updateHomeRelayStatus();
Â  Â  }
Â  Â  return;
Â  }

Â  if (forceFullDisplayUpdate) {
Â  Â  lcd.setCursor(0, 0);
Â  Â  printTime(currentTime.hour, currentTime.minute, currentTime.second, true);

Â  Â  lcd.setCursor(8, 0);
Â  Â  lcd.print(F("Â  Â  Â  Â  "));

Â  } else {
Â  Â  bool showColon = (currentTime.second % 2 != 0);

Â  Â  if (currentTime.minute != lastMinute) {
Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  if (currentTime.hour < 10) lcd.print(F("0"));
Â  Â  Â  lcd.print(currentTime.hour);
Â  Â  Â  lcd.print(F(":"));
Â  Â  Â  if (currentTime.minute < 10) lcd.print(F("0"));
Â  Â  Â  lcd.print(currentTime.minute);
Â  Â  Â  lcd.print(F("Â  Â  "));
Â  Â  }

Â  Â  lcd.setCursor(5, 0);
Â  Â  lcd.print(showColon ? F(":") : F(" "));

Â  Â  lcd.setCursor(6, 0);
Â  Â  if (currentTime.second < 10) lcd.print(F("0"));
Â  Â  lcd.print(currentTime.second);
Â  }

Â  updateHomeRelayStatus();

Â  lcd.noCursor();
Â  lcd.noBlink();
Â  lastSecond = currentTime.second;
Â  lastMinute = currentTime.minute;
}

void updateDisplay() {
Â  unsigned long currentMillis = millis();
Â  bool shouldUpdateLcdRateLimited = (currentMillis - lastLcdUpdate >= LCD_UPDATE_INTERVAL);

Â  if (!lcd_is_awake) return;Â  // **Bá» qua update náº¿u LCD Ä‘ang ngá»§**


Â  if (nav.currentState != MENU_HOME && nav.currentState != MENU_ALERT) {
Â  Â  if (!needsDisplayUpdate && !shouldUpdateLcdRateLimited) {
Â  Â  Â  return;
Â  Â  }
Â  }

Â  if (nav.currentState == MENU_ALERT) {
Â  Â  if (currentDisplayedMenu != MENU_ALERT) {
Â  Â  Â  lcd.clear();
Â  Â  Â  currentDisplayedMenu = MENU_ALERT;
Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  lcd.print(F("ALERT:"));
Â  Â  }
Â  Â  lcd.setCursor(0, 1);
Â  Â  if (currentAlertMessage != nullptr) {
Â  Â  Â  lcd.print(currentAlertMessage);
Â  Â  } else if (currentAlertMessageRam[0] != 0) {
Â  Â  Â  lcd.print(currentAlertMessageRam);
Â  Â  } else {
Â  Â  Â  lcd.print(F("UNKNOWN ALERT"));
Â  Â  }

Â  Â  return;
Â  }

Â  if (nav.currentState == MENU_HOME) {
Â  Â  if (currentDisplayedMenu != MENU_HOME) {
Â  Â  Â  lcd.clear();
Â  Â  Â  currentDisplayedMenu = MENU_HOME;
Â  Â  Â  needsDisplayUpdate = true;
Â  Â  Â  lastMinute = 60;
Â  Â  Â  lastDay = 32;
Â  Â  }

Â  Â  bool relayStatusChanged = false;
Â  Â  for (uint8_t i = 0; i < NUM_RELAYS; i++) {
Â  Â  Â  if (currentRelayOutputState[i] != lastRelayState[i]) {
Â  Â  Â  Â  relayStatusChanged = true;
Â  Â  Â  Â  break;
Â  Â  Â  }
Â  Â  }

Â  Â  bool showQuickSelect = (millis() - lastActionTime < QUICK_SELECT_TIMEOUT) && (lastActionTime != 0);
Â  Â  bool isRtcSelected = nav.selectedIndex == NUM_RELAYS;


Â  Â  if (currentTime.second != lastSecond || needsDisplayUpdate || showQuickSelect || relayStatusChanged || isRtcSelected) {
Â  Â  Â  updateHomeTime(needsDisplayUpdate || showQuickSelect || relayStatusChanged || isRtcSelected);
Â  Â  Â  lastLcdUpdate = currentMillis;
Â  Â  }
Â  Â  needsDisplayUpdate = false;
Â  Â  return;
Â  }

Â  if (needsDisplayUpdate || shouldUpdateLcdRateLimited) {
Â  Â  if (currentDisplayedMenu != nav.currentState) {
Â  Â  Â  lcd.clear();
Â  Â  Â  currentDisplayedMenu = nav.currentState;
Â  Â  Â  if (nav.currentState != MENU_RELAY_SETTINGS && nav.currentState != MENU_RTC_EDIT && nav.currentState != MENU_RTC_MAIN_MENU) {
Â  Â  Â  Â  lcd.noCursor();
Â  Â  Â  Â  lcd.noBlink();
Â  Â  Â  }
Â  Â  }

Â  Â  switch (nav.currentState) {
Â  Â  Â  case MENU_RELAY_SETTINGS:
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  uint8_t r_disp = nav.selectedIndex;
Â  Â  Â  Â  Â  RelayMenuOption selected = relays[r_disp].selectedOption;

Â  Â  Â  Â  Â  if (selected >= RELAY_STATUS_OR_TIMER1 && selected <= RELAY_TIMER4 && relays[r_disp].mode != MODE_MAN) {
Â  Â  Â  Â  Â  Â  uint8_t t_disp = selected - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  Â  Â  Â  if (timers[r_disp][t_disp].setting_step == STEP_DONE) {
Â  Â  Â  Â  Â  Â  Â  displayRelayMenu(r_disp);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  displayTimerMenu(r_disp);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  displayRelayMenu(r_disp);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  break;
Â  Â  Â  case MENU_RTC_MAIN_MENU:
Â  Â  Â  Â  displayRtcMainMenu();
Â  Â  Â  Â  break;
Â  Â  Â  case MENU_RTC_EDIT:
Â  Â  Â  Â  if (currentDisplayedMenu != MENU_RTC_EDIT) {
Â  Â  Â  Â  Â  lcd.clear();
Â  Â  Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  Â  Â  lcd.print(F("TIME"));
Â  Â  Â  Â  Â  lcd.setCursor(0, 1);
Â  Â  Â  Â  Â  lcd.print(F("DATE"));
Â  Â  Â  Â  Â  currentDisplayedMenu = MENU_RTC_EDIT;
Â  Â  Â  Â  }
Â  Â  Â  Â  displayRtcEdit_Dynamic();
Â  Â  Â  Â  updateRtcEdit_Cursor();
Â  Â  Â  Â  break;
Â  Â  Â  case MENU_SAVE_PROMPT:
Â  Â  Â  Â  lcd.setCursor(0, 0);
Â  Â  Â  Â  lcd.print(F("SETTINGS CHANGED"));
Â  Â  Â  Â  lcd.setCursor(0, 1);
Â  Â  Â  Â  if (nav.selectedIndex == 0) lcd.print(F("> SAVE DISCARD "));
Â  Â  Â  Â  else lcd.print(F(" SAVE > DISCARD"));
Â  Â  Â  Â  break;
Â  Â  Â  default:
Â  Â  Â  Â  break;
Â  Â  }
Â  Â  needsDisplayUpdate = false;
Â  Â  lastLcdUpdate = currentMillis;
Â  }
}

// 11. HÃ€M EEPROM
void saveSettings() {
Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  eepromData.relay_mode[r] = relays[r].mode;
Â  Â  eepromData.relay_status[r] = relays[r].status;
Â  Â  eepromData.sensor_gate_enabled[r] = relays[r].sensor_gate_enabled;
Â  Â  eepromData.sensor_logic[r] = relays[r].sensor_logic;
Â  Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  Â  eepromData.timers[r][t].mode = timers[r][t].mode;
Â  Â  Â  eepromData.timers[r][t].time_on = timers[r][t].time_on;
Â  Â  Â  eepromData.timers[r][t].time_off = timers[r][t].time_off;

Â  Â  Â  eepromData.timers[r][t].cycle_duration_on = timers[r][t].cycle_duration_on;
Â  Â  Â  eepromData.timers[r][t].cycle_duration_off = timers[r][t].cycle_duration_off;
Â  Â  Â  eepromData.timers[r][t].cycle_limit = timers[r][t].cycle_limit;
Â  Â  Â  eepromData.timers[r][t].cycle_count = timers[r][t].cycle_count;
Â  Â  Â  eepromData.timers[r][t].dow_mask = timers[r][t].dow_mask;

Â  Â  Â  eepromData.timers[r][t].cycle_is_on_state = (uint8_t)timers[r][t].cycle_is_on;
Â  Â  Â  eepromData.timers[r][t].cycle_start_time_sec = timers[r][t].cycle_last_state_change_time_seconds;
Â  Â  }
Â  }
Â  eepromData.magic_byte = EEPROM_MAGIC_BYTE;
Â  EEPROM.put(0, eepromData);
Â  wdt_reset();
}

void updateCycleCountsInEeprom() {
Â  size_t timerArrayAddress = offsetof(EepromData, timers);
Â  size_t cycleCountOffset = offsetof(EepromTimerData, cycle_count);
Â  size_t timerDataSize = sizeof(EepromTimerData);

Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  Â  int countAddress = timerArrayAddress + (r * NUM_TIMERS_PER_RELAY + t) * timerDataSize + cycleCountOffset;

Â  Â  Â  if (EEPROM.read(countAddress) != lowByte(timers[r][t].cycle_count) || EEPROM.read(countAddress + 1) != highByte(timers[r][t].cycle_count)) {
Â  Â  Â  Â  EEPROM.put(countAddress, timers[r][t].cycle_count);
Â  Â  Â  }
Â  Â  Â  wdt_reset();
Â  Â  }
Â  }
}

void updateCycleResumeStateInEeprom(uint8_t r, uint8_t t) {
Â  size_t timerArrayAddress = offsetof(EepromData, timers);
Â  size_t timerDataSize = sizeof(EepromTimerData);

Â  int timerAddress = timerArrayAddress + (r * NUM_TIMERS_PER_RELAY + t) * timerDataSize;

Â  size_t stateOffset = offsetof(EepromTimerData, cycle_is_on_state);
Â  int stateAddress = timerAddress + stateOffset;

Â  size_t startTimeOffset = offsetof(EepromTimerData, cycle_start_time_sec);
Â  int startTimeAddress = timerAddress + startTimeOffset;

Â  if (timers[r][t].cycle_last_state_change_time_seconds != 0) {
Â  Â  uint8_t state = timers[r][t].cycle_is_on ? 1 : 0;
Â  Â  uint32_t startTime = timers[r][t].cycle_last_state_change_time_seconds;

Â  Â  EEPROM.update(stateAddress, state);
Â  Â  EEPROM.put(startTimeAddress, startTime);
Â  } else if (timers[r][t].cycle_count >= timers[r][t].cycle_limit && timers[r][t].mode == 1 && timers[r][t].cycle_limit != 9999) {
Â  Â  EEPROM.update(stateAddress, 0);
Â  Â  EEPROM.put(startTimeAddress, (uint32_t)0);
Â  } else {
Â  Â  EEPROM.update(stateAddress, 0);
Â  Â  EEPROM.put(startTimeAddress, (uint32_t)0);
Â  }
Â  wdt_reset();
}


void updateRelayStatusInEeprom() {
Â  size_t statusArrayAddress = offsetof(EepromData, relay_status);
Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  int statusAddress = statusArrayAddress + r;
Â  Â  EEPROM.update(statusAddress, relays[r].status);
Â  }
}

void loadSettings() {
Â  EEPROM.get(0, eepromData);
Â  if (eepromData.magic_byte != EEPROM_MAGIC_BYTE) {
Â  Â  return;
Â  }
Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  relays[r].mode = eepromData.relay_mode[r];
Â  Â  relays[r].status = eepromData.relay_status[r];
Â  Â  relays[r].selectedOption = RELAY_BACK;
Â  Â  relays[r].sensor_gate_enabled = eepromData.sensor_gate_enabled[r];
Â  Â  relays[r].sensor_logic = eepromData.sensor_logic[r];

Â  Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  Â  timers[r][t].mode = eepromData.timers[r][t].mode;
Â  Â  Â  timers[r][t].time_on = eepromData.timers[r][t].time_on;
Â  Â  Â  timers[r][t].time_off = eepromData.timers[r][t].time_off;

Â  Â  Â  timers[r][t].cycle_duration_on = eepromData.timers[r][t].cycle_duration_on;
Â  Â  Â  timers[r][t].cycle_duration_off = eepromData.timers[r][t].cycle_duration_off;
Â  Â  Â  timers[r][t].cycle_limit = eepromData.timers[r][t].cycle_limit;
Â  Â  Â  timers[r][t].cycle_count = eepromData.timers[r][t].cycle_count;

Â  Â  Â  timers[r][t].dow_mask = eepromData.timers[r][t].dow_mask;

Â  Â  Â  timers[r][t].cycle_is_on = (bool)eepromData.timers[r][t].cycle_is_on_state;
Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = eepromData.timers[r][t].cycle_start_time_sec;

Â  Â  Â  // **FIX LOGIC CYCLE LIMIT:** Giá»›i háº¡n tá»‘i Ä‘a lÃ  99 (hoáº·c 9999=INF)
Â  Â  Â  if (timers[r][t].cycle_limit == 0) {
Â  Â  Â  Â  timers[r][t].cycle_limit = 9999;
Â  Â  Â  } else if (timers[r][t].cycle_limit > 99 && timers[r][t].cycle_limit != 9999) {
Â  Â  Â  Â  timers[r][t].cycle_limit = 99;Â  // Giá»›i háº¡n vá» 99 náº¿u vÆ°á»£t quÃ¡ nhÆ°ng khÃ´ng pháº£i INF
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  }

Â  Â  Â  if (timers[r][t].cycle_count > 9999) {
Â  Â  Â  Â  timers[r][t].cycle_count = 0;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  }

Â  Â  Â  if (timers[r][t].cycle_limit != 9999 && timers[r][t].cycle_count > timers[r][t].cycle_limit) {
Â  Â  Â  Â  timers[r][t].cycle_count = timers[r][t].cycle_limit;
Â  Â  Â  Â  timers[r][t].cycle_is_on = false;
Â  Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = 0;
Â  Â  Â  Â  cycle_count_changed = true;
Â  Â  Â  }


Â  Â  Â  if (timers[r][t].cycle_duration_on.minute == 0 && timers[r][t].cycle_duration_on.second == 0) {
Â  Â  Â  Â  timers[r][t].cycle_duration_on.second = 1;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  }
Â  Â  Â  if (timers[r][t].cycle_duration_off.minute == 0 && timers[r][t].cycle_duration_off.second == 0) {
Â  Â  Â  Â  timers[r][t].cycle_duration_off.second = 1;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  }

Â  Â  Â  timers[r][t].cached_on_sec = (uint32_t)timers[r][t].cycle_duration_on.minute * 60 + timers[r][t].cycle_duration_on.second;
Â  Â  Â  timers[r][t].cached_off_sec = (uint32_t)timers[r][t].cycle_duration_off.minute * 60 + timers[r][t].cycle_duration_off.second;
Â  Â  Â  timers[r][t].cached_time_on_sec = (uint32_t)timers[r][t].time_on.hour * 3600 + (uint32_t)timers[r][t].time_on.minute * 60;
Â  Â  Â  timers[r][t].cached_time_off_sec = (uint32_t)timers[r][t].time_off.hour * 3600 + (uint32_t)timers[r][t].time_off.minute * 60;

Â  Â  Â  timers[r][t].setting_step = STEP_DONE;
Â  Â  Â  timers[r][t].selectedOption = TIMER_BACK;
Â  Â  }
Â  }
}

void resetSettings() {
Â  for (uint8_t r = 0; r < NUM_RELAYS; r++) {
Â  Â  if (r == 0 || r == 1) {
Â  Â  Â  relays[r].mode = MODE_MAN;
Â  Â  Â  relays[r].status = 1;
Â  Â  } else if (r == 2) {
Â  Â  Â  relays[r].mode = MODE_AUT;
Â  Â  Â  relays[r].status = 0;
Â  Â  } else if (r == 3) {
Â  Â  Â  relays[r].mode = MODE_CYC;
Â  Â  Â  relays[r].status = 0;
Â  Â  } else {
Â  Â  Â  relays[r].mode = MODE_AUT;
Â  Â  Â  relays[r].status = 0;
Â  Â  }

Â  Â  relays[r].selectedOption = RELAY_BACK;
Â  Â  relays[r].sensor_gate_enabled = false;
Â  Â  relays[r].sensor_logic = SENSOR_LOGIC_LOW_ACTIVE;

Â  Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  Â  timers[r][t].setting_step = STEP_DONE;
Â  Â  Â  timers[r][t].selectedOption = TIMER_BACK;
Â  Â  Â  timers[r][t].dow_mask = 0b01111111;

Â  Â  Â  timers[r][t].cycle_is_on = false;
Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = 0;

Â  Â  Â  timers[r][t].mode = 0;
Â  Â  Â  timers[r][t].cycle_duration_on.minute = 0;
Â  Â  Â  timers[r][t].cycle_duration_on.second = 10;
Â  Â  Â  timers[r][t].cycle_duration_off.minute = 0;
Â  Â  Â  timers[r][t].cycle_duration_off.second = 5;
Â  Â  Â  timers[r][t].cycle_limit = 9999;
Â  Â  Â  timers[r][t].cycle_count = 0;
Â  Â  Â  timers[r][t].time_on.hour = 8;
Â  Â  Â  timers[r][t].time_off.hour = 17;
Â  Â  Â  timers[r][t].time_on.minute = 0;
Â  Â  Â  timers[r][t].time_off.minute = 0;

Â  Â  Â  if (t == 0) {
Â  Â  Â  Â  if (r == 2) {
Â  Â  Â  Â  Â  timers[r][t].mode = 1;
Â  Â  Â  Â  Â  timers[r][t].time_on.hour = 11;
Â  Â  Â  Â  Â  timers[r][t].time_off.hour = 21;
Â  Â  Â  Â  Â  timers[r][t].time_on.minute = 0;
Â  Â  Â  Â  Â  timers[r][t].time_off.minute = 0;
Â  Â  Â  Â  } else if (r == 3) {
Â  Â  Â  Â  Â  timers[r][t].mode = 1;
Â  Â  Â  Â  Â  timers[r][t].time_on.hour = 22;
Â  Â  Â  Â  Â  timers[r][t].time_off.hour = 22;
Â  Â  Â  Â  Â  timers[r][t].time_on.minute = 0;
Â  Â  Â  Â  Â  timers[r][t].time_off.minute = 10;

Â  Â  Â  Â  Â  timers[r][t].cycle_duration_on.minute = 5;
Â  Â  Â  Â  Â  timers[r][t].cycle_duration_on.second = 0;
Â  Â  Â  Â  Â  timers[r][t].cycle_duration_off.minute = 5;
Â  Â  Â  Â  Â  timers[r][t].cycle_duration_off.second = 0;
Â  Â  Â  Â  Â  timers[r][t].cycle_limit = 1;
Â  Â  Â  Â  } else if (r == 0 || r == 1) {
Â  Â  Â  Â  Â  timers[r][t].mode = 0;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  timers[r][t].cached_on_sec = (uint32_t)timers[r][t].cycle_duration_on.minute * 60 + timers[r][t].cycle_duration_on.second;
Â  Â  Â  timers[r][t].cached_off_sec = (uint32_t)timers[r][t].cycle_duration_off.minute * 60 + timers[r][t].cycle_duration_off.second;

Â  Â  Â  timers[r][t].cached_time_on_sec = (uint32_t)timers[r][t].time_on.hour * 3600 + (uint32_t)timers[r][t].time_on.minute * 60;
Â  Â  Â  timers[r][t].cached_time_off_sec = (uint32_t)timers[r][t].time_off.hour * 3600 + (uint32_t)timers[r][t].time_off.minute * 60;
Â  Â  }
Â  }

Â  eepromData.magic_byte = 0;
Â  saveSettings();
Â  updateCycleCountsInEeprom();
Â  updateRelayStatusInEeprom();
}


// 12. LOGIC ÄIá»€U KHIá»‚N RELAY
int8_t getActiveCycleTimerIndex(uint8_t r, uint32_t currentTimeSeconds) {
Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  if (timers[r][t].mode == 1) {

Â  Â  Â  uint32_t timeOnSeconds = timers[r][t].cached_time_on_sec;
Â  Â  Â  uint32_t timeOffSeconds = timers[r][t].cached_time_off_sec;

Â  Â  Â  bool isOvernight = (timeOnSeconds >= timeOffSeconds);

Â  Â  Â  if (!isOvernight) {
Â  Â  Â  Â  if ((timers[r][t].dow_mask & currentDayMask) && (currentTimeSeconds >= timeOnSeconds && currentTimeSeconds < timeOffSeconds)) {
Â  Â  Â  Â  Â  return t;
Â  Â  Â  Â  }
Â  Â  Â  } else {

Â  Â  Â  Â  if (currentTimeSeconds >= timeOnSeconds) {
Â  Â  Â  Â  Â  if (timers[r][t].dow_mask & currentDayMask) {
Â  Â  Â  Â  Â  Â  return t;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (currentTimeSeconds < timeOffSeconds) {
Â  Â  Â  Â  Â  if (timers[r][t].dow_mask & previousDayMask) {
Â  Â  Â  Â  Â  Â  return t;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  }
Â  return -1;
}
uint8_t runManualMode(uint8_t r) {
Â  return (relays[r].status == 1) ? HIGH : LOW;
}

uint8_t runAutoTimerMode(uint8_t r, uint32_t currentTimeSeconds) {
Â  bool shouldBeOn = false;

Â  if (!rtc_initialized) return LOW;

Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  if (timers[r][t].cycle_last_state_change_time_seconds != 0) {
Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = 0;
Â  Â  Â  timers[r][t].cycle_is_on = false;
Â  Â  }
Â  }


Â  for (uint8_t t = 0; t < NUM_TIMERS_PER_RELAY; t++) {
Â  Â  if (timers[r][t].mode == 1) {

Â  Â  Â  uint32_t timeOnSeconds = timers[r][t].cached_time_on_sec;
Â  Â  Â  uint32_t timeOffSeconds = timers[r][t].cached_time_off_sec;

Â  Â  Â  bool isOvernight = (timeOnSeconds >= timeOffSeconds);

Â  Â  Â  if (!isOvernight) {
Â  Â  Â  Â  if ((timers[r][t].dow_mask & currentDayMask) == 0) {
Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  }
Â  Â  Â  Â  if (currentTimeSeconds >= timeOnSeconds && currentTimeSeconds < timeOffSeconds) {
Â  Â  Â  Â  Â  shouldBeOn = true;
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  Â  } else {

Â  Â  Â  Â  if (currentTimeSeconds >= timeOnSeconds) {
Â  Â  Â  Â  Â  if ((timers[r][t].dow_mask & currentDayMask) == 0) {
Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  shouldBeOn = true;
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }

Â  Â  Â  Â  else if (currentTimeSeconds < timeOffSeconds) {
Â  Â  Â  Â  Â  if ((timers[r][t].dow_mask & previousDayMask) == 0) {
Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  shouldBeOn = true;
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  }
Â  return shouldBeOn ? HIGH : LOW;
}

uint8_t runCycleMode(uint8_t r, int8_t activeTimerIndex, uint32_t currentTimeSeconds) {
Â  uint8_t desiredState = LOW;

Â  if (!rtc_initialized) return LOW;

Â  if (activeTimerIndex != -1) {
Â  Â  uint8_t t = activeTimerIndex;
Â  Â  TimerData* timer = &timers[r][t];

Â  Â  if (timer->cycle_limit != 9999 && timer->cycle_count >= timer->cycle_limit) {
Â  Â  Â  if (timer->cycle_last_state_change_time_seconds != 0) {
Â  Â  Â  Â  timer->cycle_is_on = false;
Â  Â  Â  Â  timer->cycle_last_state_change_time_seconds = 0;
Â  Â  Â  Â  updateCycleResumeStateInEeprom(r, t);
Â  Â  Â  }
Â  Â  Â  return LOW;
Â  Â  }


Â  Â  uint32_t onDurationSec = timer->cached_on_sec;
Â  Â  uint32_t offDurationSec = timer->cached_off_sec;

Â  Â  if (timer->cycle_last_state_change_time_seconds == 0) {
Â  Â  Â  if (timer->cycle_count < timer->cycle_limit || timer->cycle_limit == 9999) {
Â  Â  Â  Â  timer->cycle_is_on = true;
Â  Â  Â  Â  timer->cycle_last_state_change_time_seconds = currentTimeSeconds;

Â  Â  Â  Â  if (timer->cycle_count != cycleCountBuffer[r][t]) {
Â  Â  Â  Â  Â  timer->cycle_count = cycleCountBuffer[r][t];
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  return LOW;
Â  Â  Â  }
Â  Â  }

Â  Â  uint32_t elapsed_since_change = currentTimeSeconds - timer->cycle_last_state_change_time_seconds;

Â  Â  if (timer->cycle_last_state_change_time_seconds > currentTimeSeconds) {
Â  Â  Â  elapsed_since_change = (86400 - timer->cycle_last_state_change_time_seconds) + currentTimeSeconds;
Â  Â  }

Â  Â  if (timer->cycle_is_on) {
Â  Â  Â  if (elapsed_since_change >= onDurationSec) {
Â  Â  Â  Â  timer->cycle_is_on = false;
Â  Â  Â  Â  timer->cycle_last_state_change_time_seconds = currentTimeSeconds;

Â  Â  Â  Â  if (timer->cycle_limit != 9999) {
Â  Â  Â  Â  Â  cycleCountBuffer[r][t]++;
Â  Â  Â  Â  Â  timers[r][t].cycle_count++;

Â  Â  Â  Â  Â  if (abs(cycleCountBuffer[r][t] - timers[r][t].cycle_count) >= CYCLE_COUNT_THRESHOLD || cycleCountBuffer[r][t] >= timers[r][t].cycle_limit) {
Â  Â  Â  Â  Â  Â  cycle_count_changed = true;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  if (elapsed_since_change >= offDurationSec) {
Â  Â  Â  Â  timer->cycle_is_on = true;
Â  Â  Â  Â  timer->cycle_last_state_change_time_seconds = currentTimeSeconds;
Â  Â  Â  }
Â  Â  }

Â  Â  desiredState = timer->cycle_is_on ? HIGH : LOW;

Â  } else {
Â  Â  for (uint8_t t_reset = 0; t_reset < NUM_TIMERS_PER_RELAY; t_reset++) {
Â  Â  Â  if (timers[r][t_reset].mode == 1) {
Â  Â  Â  Â  bool wasActive = timers[r][t_reset].cycle_last_state_change_time_seconds != 0;
Â  Â  Â  Â  bool wasCompleted = timers[r][t_reset].cycle_count >= timers[r][t_reset].cycle_limit && timers[r][t_reset].cycle_limit != 9999;

Â  Â  Â  Â  if (wasActive || wasCompleted) {
Â  Â  Â  Â  Â  timers[r][t_reset].cycle_last_state_change_time_seconds = 0;
Â  Â  Â  Â  Â  timers[r][t_reset].cycle_is_on = false;

Â  Â  Â  Â  Â  if (wasCompleted) {
Â  Â  Â  Â  Â  Â  timers[r][t_reset].cycle_count = 0;
Â  Â  Â  Â  Â  Â  cycleCountBuffer[r][t_reset] = 0;
Â  Â  Â  Â  Â  Â  cycle_count_changed = true;
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  updateCycleResumeStateInEeprom(r, t_reset);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  Â  desiredState = LOW;
Â  }

Â  return desiredState;
}


void runRelay(uint8_t r, uint32_t currentTimeSeconds) {
Â  uint8_t pin = relayPins[r];
Â  uint8_t desiredState = LOW;
Â  int8_t activeTimerIndex = -1;

Â  if (relays[r].mode == MODE_CYC) {
Â  Â  activeTimerIndex = getActiveCycleTimerIndex(r, currentTimeSeconds);
Â  }

Â  switch (relays[r].mode) {
Â  Â  case MODE_MAN:
Â  Â  Â  desiredState = runManualMode(r);
Â  Â  Â  break;
Â  Â  case MODE_AUT:
Â  Â  Â  desiredState = runAutoTimerMode(r, currentTimeSeconds);
Â  Â  Â  break;
Â  Â  case MODE_CYC:
Â  Â  Â  desiredState = runCycleMode(r, activeTimerIndex, currentTimeSeconds);
Â  Â  Â  break;
Â  Â  default:
Â  Â  Â  desiredState = LOW;
Â  Â  Â  break;
Â  }

Â  // Sensor Gate Logic
Â  if (relays[r].sensor_gate_enabled) {
Â  Â  if (desiredState == HIGH) {
Â  Â  Â  bool conditionMet = isSensorConditionMet(r);
Â  Â  Â  if (!conditionMet) {
Â  Â  Â  Â  desiredState = LOW;
Â  Â  Â  }
Â  Â  }
Â  }


Â  if (currentRelayOutputState[r] != desiredState) {
Â  Â  digitalWrite(pin, desiredState);
Â  Â  currentRelayOutputState[r] = desiredState;
Â  }
}

// 13. HÃ€M Há»– TRá»¢ UX
bool isSensorConditionMet(uint8_t r) {
Â  int reading = digitalRead(SENSOR_PINS[r]);

Â  if (relays[r].sensor_logic == SENSOR_LOGIC_LOW_ACTIVE) {
Â  Â  return (reading == LOW);
Â  } else {
Â  Â  return (reading == HIGH);
Â  }
}

const __FlashStringHelper* getModeStr(RelayMode mode) {
Â  if (mode == MODE_MAN) return F("MAN");
Â  if (mode == MODE_AUT) return F("AUT");
Â  return F("CYC");
}

const __FlashStringHelper* getDayStr(uint8_t dayOfWeek) {
Â  switch (dayOfWeek) {
Â  Â  case 1: return F("T2");
Â  Â  case 2: return F("T3");
Â  Â  case 3: return F("T4");
Â  Â  case 4: return F("T5");
Â  Â  case 5: return F("T6");
Â  Â  case 6: return F("T7");
Â  Â  case 0:
Â  Â  default: return F("CN");
Â  }
}

const __FlashStringHelper* getDowMenuStr(uint8_t index) {
Â  switch (index) {
Â  Â  case 0: return F("T2");
Â  Â  case 1: return F("T3");
Â  Â  case 2: return F("T4");
Â  Â  case 3: return F("T5");
Â  Â  case 4: return F("T6");
Â  Â  case 5: return F("T7");
Â  Â  case 6: return F("CN");
Â  Â  case 7: return F("ALL");
Â  Â  case 8: return F("NONE");
Â  Â  case 9: return F("WKDAY");
Â  Â  case 10: return F("BACK");
Â  Â  default: return F("--");
Â  }
}


void printTime(uint8_t hour, uint8_t minute, uint8_t second, bool includeSeconds) {
Â  if (hour < 10) lcd.print(F("0"));
Â  lcd.print(hour);
Â  lcd.print(F(":"));
Â  if (minute < 10) lcd.print(F("0"));
Â  lcd.print(minute);
Â  if (includeSeconds) {
Â  Â  lcd.print(F(":"));
Â  Â  if (second < 10) lcd.print(F("0"));
Â  Â  lcd.print(second);
Â  }
}

// HÃ m showAlert cho chuá»—i PROGMEM (chá»§ yáº¿u lÃ  háº±ng sá»‘)
void showAlert(const __FlashStringHelper* message) {
Â  if (nav.currentState != MENU_ALERT) {
Â  Â  stateBeforeAlert = nav.currentState;
Â  }

Â  currentAlertMessage = message;
Â  currentAlertMessageRam[0] = 0;Â  // Äáº£m báº£o RAM buffer rá»—ng
Â  alertStartTime = millis();
Â  nav.currentState = MENU_ALERT;
Â  needsDisplayUpdate = true;
Â  lcd.noCursor();
Â  lcd.noBlink();
}

// **Má»šI: HÃ m showAlert cho chuá»—i RAM (thÃ´ng bÃ¡o Ä‘á»™ng)**
void showAlertRam(const char* message) {
Â  if (nav.currentState != MENU_ALERT) {
Â  Â  stateBeforeAlert = nav.currentState;
Â  }

Â  strncpy(currentAlertMessageRam, message, sizeof(currentAlertMessageRam) - 1);
Â  currentAlertMessageRam[sizeof(currentAlertMessageRam) - 1] = 0;
Â  currentAlertMessage = nullptr;Â  // Äáº£m báº£o PROGMEM pointer rá»—ng
Â  alertStartTime = millis();
Â  nav.currentState = MENU_ALERT;
Â  needsDisplayUpdate = true;
Â  lcd.noCursor();
Â  lcd.noBlink();
}

void printCycleTime(uint8_t minute, uint8_t second) {
Â  if (minute < 10) lcd.print(F("0"));
Â  lcd.print(minute);
Â  lcd.print(F("M"));
Â  if (second < 10) lcd.print(F("0"));
Â  lcd.print(second);
Â  lcd.print(F("S"));
}

void printPaddedLimit(uint16_t limit, bool includeSeconds) {
Â  if (limit > 99 && limit != 9999) {
Â  Â  limit = 99;
Â  }

Â  if (limit == 9999) {
Â  Â  lcd.print(F("INF"));
Â  Â  if (includeSeconds) lcd.print(F(" "));
Â  } else {
Â  Â  if (limit < 10) lcd.print(F("0"));
Â  Â  lcd.print(limit);
Â  Â  lcd.print(F("Â  "));
Â  }
}

void updateTimeValue(uint8_t r, uint8_t t, bool isHour, bool isUp, uint8_t step) {
Â  uint8_t* valToChange;
Â  uint8_t maxVal;
Â  if (timers[r][t].selectedOption == TIMER_ON_TIME) {
Â  Â  valToChange = isHour ? &timers[r][t].time_on.hour : &timers[r][t].time_on.minute;
Â  } else {
Â  Â  valToChange = isHour ? &timers[r][t].time_off.hour : &timers[r][t].time_off.minute;
Â  }
Â  maxVal = isHour ? 23 : 59;
Â  if (isUp) {
Â  Â  *valToChange = (*valToChange + step > maxVal) ? (*valToChange + step) - (maxVal + 1) : *valToChange + step;
Â  } else {
Â  Â  *valToChange = (*valToChange < step) ? (maxVal + 1) - (step - *valToChange) : *valToChange - step;
Â  }
Â  uint8_t col_start_index = (timers[r][t].selectedOption == TIMER_ON_TIME) ? 6 : 7;
Â  uint8_t col = isHour ? col_start_index : col_start_index + 3;
Â  lcd.setCursor(col, 1);
Â  if (*valToChange < 10) lcd.print(F("0"));
Â  lcd.print(*valToChange);

Â  if (timers[r][t].selectedOption == TIMER_ON_TIME) {
Â  Â  timers[r][t].cached_time_on_sec = (uint32_t)timers[r][t].time_on.hour * 3600 + (uint32_t)timers[r][t].time_on.minute * 60;
Â  } else {
Â  Â  timers[r][t].cached_time_off_sec = (uint32_t)timers[r][t].time_off.hour * 3600 + (uint32_t)timers[r][t].time_off.minute * 60;
Â  }
}

void updateDurationValue(uint8_t r, uint8_t t, bool isMinute, bool isUp, uint16_t step) {
Â  (void)step;
Â  uint8_t* valToChange;
Â  uint16_t maxVal;
Â  TimerMenuOption currentOption = timers[r][t].selectedOption;
Â  TimeDuration* duration = nullptr;

Â  if (currentOption == TIMER_CYCLE_ON_DUR) {
Â  Â  duration = &timers[r][t].cycle_duration_on;
Â  Â  valToChange = isMinute ? &duration->minute : &duration->second;
Â  } else if (currentOption == TIMER_CYCLE_OFF_DUR) {
Â  Â  duration = &timers[r][t].cycle_duration_off;
Â  Â  valToChange = isMinute ? &duration->minute : &duration->second;
Â  } else {
Â  Â  return;
Â  }

Â  maxVal = 59;
Â  uint8_t step_size = 1;

Â  if (isUp) {
Â  Â  *valToChange = (*valToChange + step_size > maxVal) ? (*valToChange + step_size) - (maxVal + 1) : *valToChange + step_size;
Â  } else {
Â  Â  if (*valToChange < step_size) {
Â  Â  Â  *valToChange = (maxVal + 1) - (step_size - *valToChange);
Â  Â  } else {
Â  Â  Â  *valToChange = *valToChange - step_size;
Â  Â  }
Â  }

Â  if (duration->minute == 0 && duration->second == 0) {
Â  Â  duration->second = 1;
Â  }

Â  lcd.setCursor(6, 1);
Â  lcd.print(F("Â  Â  Â  Â  Â "));
Â  lcd.setCursor(6, 1);

Â  TimeDuration duration_display = *duration;

Â  if (currentOption == TIMER_CYCLE_OFF_DUR) lcd.print(F(" "));
Â  printCycleTime(duration_display.minute, duration_display.second);

Â  if (currentOption == TIMER_CYCLE_ON_DUR) {
Â  Â  timers[r][t].cached_on_sec = (uint32_t)duration->minute * 60 + duration->second;
Â  } else {
Â  Â  timers[r][t].cached_off_sec = (uint32_t)duration->minute * 60 + duration->second;
Â  }
}

void updateCountValue(uint8_t r, uint8_t t, bool isUp, uint16_t step) {
Â  (void)step;
Â  uint16_t* valToChange = &timers[r][t].cycle_limit;
Â  uint16_t maxValDisplay = 99;
Â  uint16_t currentVal = *valToChange;

Â  if (currentVal > 99) currentVal = maxValDisplay;

Â  uint16_t actual_step = 1;

Â  if (isUp) {
Â  Â  if (currentVal == maxValDisplay) {
Â  Â  Â  currentVal = 1;
Â  Â  } else {
Â  Â  Â  currentVal = (currentVal + actual_step > maxValDisplay) ? maxValDisplay : currentVal + actual_step;
Â  Â  }
Â  } else {
Â  Â  if (currentVal == 1 || currentVal == 0) {
Â  Â  Â  currentVal = maxValDisplay;
Â  Â  } else {
Â  Â  Â  if (currentVal < actual_step) {
Â  Â  Â  Â  currentVal = 1;
Â  Â  Â  } else {
Â  Â  Â  Â  currentVal = currentVal - actual_step;
Â  Â  Â  }
Â  Â  }
Â  }

Â  if (currentVal < 1) currentVal = 1;

Â  *valToChange = currentVal;

Â  if (*valToChange < timers[r][t].cycle_count) {
Â  Â  timers[r][t].cycle_count = *valToChange;
Â  Â  cycleCountBuffer[r][t] = *valToChange;
Â  }

Â  lcd.setCursor(10, 1);
Â  lcd.print(F("Â  Â  "));
Â  lcd.setCursor(10, 1);
Â  printPaddedLimit(*valToChange, true);
}


void updateCursorPos(uint8_t r, uint8_t t) {
Â  if (!lcd_is_awake) return;

Â  uint8_t col = 0;
Â  SettingStep step = timers[r][t].setting_step;
Â  TimerMenuOption selected = timers[r][t].selectedOption;

Â  lcd.cursor();
Â  lcd.blink();

Â  if (selected == TIMER_DOW_SETTING) {
Â  Â  if (step != STEP_NAV_TIMER) {
Â  Â  Â  lcd.setCursor(3, 1);
Â  Â  } else {
Â  Â  Â  lcd.noCursor();
Â  Â  Â  lcd.noBlink();
Â  Â  }
Â  Â  return;
Â  }

Â  switch (selected) {
Â  Â  case TIMER_ON_TIME:
Â  Â  case TIMER_OFF_TIME:
Â  Â  Â  col = (selected == TIMER_ON_TIME) ? 6 : 7;
Â  Â  Â  if (step == STEP_MM) col += 3;
Â  Â  Â  break;
Â  Â  case TIMER_CYCLE_ON_DUR:
Â  Â  case TIMER_CYCLE_OFF_DUR:
Â  Â  Â  col = 9;
Â  Â  Â  if (selected == TIMER_CYCLE_OFF_DUR) col += 1;
Â  Â  Â  if (step == STEP_MM) col += 4;
Â  Â  Â  break;
Â  Â  case TIMER_CYCLE_LIMIT:
Â  Â  Â  col = 10;
Â  Â  Â  break;
Â  Â  default:
Â  Â  Â  lcd.noCursor();
Â  Â  Â  lcd.noBlink();
Â  Â  Â  return;
Â  }

Â  if (col > 0) {
Â  Â  lcd.setCursor(col, 1);
Â  } else {
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  }
}

// 14. HÃ€M HIá»‚N THá»Š MENU
void displayRelayMenu(uint8_t r) {
Â  if (!lcd_is_awake) return;

Â  const __FlashStringHelper* modeStr = getModeStr(relays[r].mode);

Â  lcd.setCursor(0, 0);
Â  lcd.print(F("R"));
Â  lcd.print(r + 1);
Â  lcd.print(F(": "));
Â  lcd.print(modeStr);
Â  lcd.print(F(" ("));
Â  lcd.print(currentRelayOutputState[r] == HIGH ? RELAY_ON_CHAR : RELAY_OFF_CHAR);
Â  lcd.print(F(") "));

Â  if (relays[r].sensor_gate_enabled) {
Â  Â  lcd.print(F("SEN"));
Â  Â  if (relays[r].sensor_logic == SENSOR_LOGIC_LOW_ACTIVE) {
Â  Â  Â  lcd.print(F("L*"));
Â  Â  } else {
Â  Â  Â  lcd.print(F("H*"));
Â  Â  }
Â  } else {
Â  Â  lcd.print(F("Â  Â  "));
Â  }

Â  lcd.noCursor();
Â  lcd.noBlink();

Â  lcd.setCursor(0, 1);
Â  lcd.print(F("Â  Â  Â  Â  Â  Â  Â  Â  "));
Â  lcd.setCursor(0, 1);

Â  lcd.print(F("> "));
Â  switch (relays[r].selectedOption) {
Â  Â  case RELAY_BACK:
Â  Â  Â  lcd.print(F("BACKÂ  Â  Â  Â  Â  Â  Â "));
Â  Â  Â  break;
Â  Â  case RELAY_MODE:
Â  Â  Â  lcd.print(F("MODE: "));
Â  Â  Â  lcd.print(modeStr);
Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â  "));
Â  Â  Â  break;
Â  Â  case RELAY_STATUS_OR_TIMER1:
Â  Â  Â  if (relays[r].mode == MODE_MAN) {
Â  Â  Â  Â  lcd.print(F("STATUS: "));
Â  Â  Â  Â  lcd.print(relays[r].status == 1 ? (const __FlashStringHelper*)STR_ON : (const __FlashStringHelper*)STR_OFF);
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â "));
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F("TIMER 1 "));
Â  Â  Â  Â  lcd.print(timers[r][0].mode == 1 ? F("ON ") : F("OFF "));
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â "));
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RELAY_TIMER2:
Â  Â  Â  if (relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  lcd.print(F("TIMER 2 "));
Â  Â  Â  Â  lcd.print(timers[r][1].mode == 1 ? F("ON ") : F("OFF "));
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â "));
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F("TIMER 2 (N/A)Â  Â "));
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RELAY_TIMER3:
Â  Â  Â  if (relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  lcd.print(F("TIMER 3 "));
Â  Â  Â  Â  lcd.print(timers[r][2].mode == 1 ? F("ON ") : F("OFF "));
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â "));
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F("TIMER 3 (N/A)Â  Â "));
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RELAY_TIMER4:
Â  Â  Â  if (relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  lcd.print(F("TIMER 4 "));
Â  Â  Â  Â  lcd.print(timers[r][3].mode == 1 ? F("ON ") : F("OFF "));
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â "));
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F("TIMER 4 (N/A)Â  Â "));
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RELAY_SENSOR_GATE:
Â  Â  Â  lcd.print(F("SEN GATE: "));
Â  Â  Â  lcd.print(relays[r].sensor_gate_enabled ? (const __FlashStringHelper*)STR_ON : (const __FlashStringHelper*)STR_OFF);
Â  Â  Â  lcd.print(F("Â  Â  Â  Â  "));
Â  Â  Â  break;
Â  Â  case RELAY_SENSOR_LOGIC:
Â  Â  Â  lcd.print(F("SEN LOGIC: "));
Â  Â  Â  if (relays[r].sensor_logic == SENSOR_LOGIC_LOW_ACTIVE) {
Â  Â  Â  Â  lcd.print(F("LOW=ACTV"));
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F("HIGH=ACTV"));
Â  Â  Â  }
Â  Â  Â  lcd.print(F("Â  Â  "));
Â  Â  Â  break;
Â  }
}

void displayTimerMenu(uint8_t r) {
Â  if (!lcd_is_awake) return;

Â  uint8_t t = relays[r].selectedOption - RELAY_STATUS_OR_TIMER1;
Â  uint16_t currentCount = cycleCountBuffer[r][t];
Â  const __FlashStringHelper* timerModeStr = timers[r][t].mode == 1 ? F("ON ") : F("OFF ");

Â  lcd.setCursor(0, 0);
Â  lcd.print(F("R"));
Â  lcd.print(r + 1);
Â  lcd.print(F("T"));
Â  lcd.print(t + 1);

Â  if (timers[r][t].selectedOption != TIMER_DOW_SETTING) {
Â  Â  lcd.print(timerModeStr);
Â  Â  if (relays[r].mode == MODE_CYC) {
Â  Â  Â  lcd.print(F(" C:"));
Â  Â  Â  printPaddedLimit(currentCount, false);
Â  Â  Â  lcd.print(F(" "));
Â  Â  } else {
Â  Â  Â  lcd.print(F("Â  Â  Â  Â  "));
Â  Â  }
Â  } else {
Â  Â  lcd.print(F(" DOW EDIT"));
Â  Â  lcd.print(F("Â  Â  Â  "));
Â  }


Â  lcd.setCursor(0, 1);
Â  lcd.print(F("> "));
Â  if (timers[r][t].setting_step == STEP_NAV_TIMER) {
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  }


Â  if (timers[r][t].selectedOption == TIMER_BACK) {
Â  Â  lcd.print(F("BACKÂ  Â  Â  Â  Â  Â  Â "));
Â  } else if (timers[r][t].selectedOption == TIMER_MODE) {
Â  Â  lcd.print(F("MODE: "));
Â  Â  lcd.print(timers[r][t].mode == 1 ? (const __FlashStringHelper*)STR_ON : (const __FlashStringHelper*)STR_OFF);
Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â  Â "));
Â  } else if (timers[r][t].selectedOption == TIMER_DOW_SETTING) {
Â  Â  if (timers[r][t].setting_step == STEP_NAV_TIMER) {
Â  Â  Â  lcd.print(F("DOW: "));
Â  Â  Â  uint8_t mask = timers[r][t].dow_mask;
Â  Â  Â  if (mask == 0b01111111) {
Â  Â  Â  Â  lcd.print(F("ALL DAYSÂ  Â  Â  Â  Â  Â "));
Â  Â  Â  } else if (mask == 0b00111111) {
Â  Â  Â  Â  lcd.print(F("WEEKDAYSÂ  Â  Â  Â  Â  Â "));
Â  Â  Â  } else if (mask == 0x00) {
Â  Â  Â  Â  lcd.print(F("NONEÂ  Â  Â  Â  Â  Â  Â  Â "));
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F("T:"));
Â  Â  Â  Â  for (uint8_t i = 0; i < 7; i++) {
Â  Â  Â  Â  Â  if (mask & (1 << i)) {
Â  Â  Â  Â  Â  Â  if (i == 6) lcd.print(F("C"));
Â  Â  Â  Â  Â  Â  else lcd.print(i + 2);
Â  Â  Â  Â  Â  } else lcd.print(F("-"));
Â  Â  Â  Â  }
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  "));
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  uint8_t cursor = dow_cursor[r][t];
Â  Â  Â  const __FlashStringHelper* dayStr = getDowMenuStr(cursor);

Â  Â  Â  if (cursor < 7) {
Â  Â  Â  Â  lcd.print(F("["));
Â  Â  Â  Â  lcd.print(dayStr);
Â  Â  Â  Â  lcd.print(F("] "));

Â  Â  Â  Â  uint8_t mask = timers[r][t].dow_mask;
Â  Â  Â  Â  bool is_on = (mask & (1 << cursor));
Â  Â  Â  Â  if (is_on) {
Â  Â  Â  Â  Â  lcd.print((const __FlashStringHelper*)STR_ON);
Â  Â  Â  Â  Â  lcd.print(RELAY_ON_CHAR);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  lcd.print((const __FlashStringHelper*)STR_OFF);
Â  Â  Â  Â  Â  lcd.print(RELAY_OFF_CHAR);
Â  Â  Â  Â  }
Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  Â  Â "));
Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  } else {
Â  Â  Â  Â  lcd.print(F(" ["));
Â  Â  Â  Â  lcd.print(dayStr);
Â  Â  Â  Â  lcd.print(F("]Â  Â  Â  Â  Â  "));
Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  }
Â  Â  }

Â  } else if (timers[r][t].selectedOption == TIMER_RESET_COUNT) {
Â  Â  if (relays[r].mode == MODE_CYC) {
Â  Â  Â  lcd.print(F("RST-C: COUNT "));
Â  Â  Â  printPaddedLimit(currentCount, false);
Â  Â  Â  lcd.print(F("Â  Â  "));
Â  Â  } else {
Â  Â  Â  lcd.print(F("MODE ERRÂ  Â  Â  Â  Â  Â  Â "));
Â  Â  }
Â  } else {
Â  Â  switch (timers[r][t].selectedOption) {
Â  Â  Â  case TIMER_ON_TIME:
Â  Â  Â  case TIMER_OFF_TIME:
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  const __FlashStringHelper* label = (timers[r][t].selectedOption == TIMER_ON_TIME) ? F("ON:") : F("OFF:");
Â  Â  Â  Â  Â  TimeOfDay_MinOnly* timeToDisplay = (timers[r][t].selectedOption == TIMER_ON_TIME) ? &timers[r][t].time_on : &timers[r][t].time_off;

Â  Â  Â  Â  Â  if (relays[r].mode == MODE_AUT || relays[r].mode == MODE_CYC) {
Â  Â  Â  Â  Â  Â  lcd.print(label);
Â  Â  Â  Â  Â  Â  lcd.print(F("Â  Â  "));
Â  Â  Â  Â  Â  Â  lcd.setCursor(6, 1);
Â  Â  Â  Â  Â  Â  if (timeToDisplay->hour < 10) lcd.print(F("0"));
Â  Â  Â  Â  Â  Â  lcd.print(timeToDisplay->hour);
Â  Â  Â  Â  Â  Â  lcd.print(F(":"));
Â  Â  Â  Â  Â  Â  if (timeToDisplay->minute < 10) lcd.print(F("0"));
Â  Â  Â  Â  Â  Â  lcd.print(timeToDisplay->minute);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  lcd.print(F("MODE ERRÂ  Â  Â  Â  Â  Â  Â "));
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  "));

Â  Â  Â  Â  Â  if (timers[r][t].setting_step <= STEP_MM) {
Â  Â  Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  break;
Â  Â  Â  case TIMER_CYCLE_ON_DUR:
Â  Â  Â  case TIMER_CYCLE_OFF_DUR:
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  TimeDuration dur = (timers[r][t].selectedOption == TIMER_CYCLE_ON_DUR) ? timers[r][t].cycle_duration_on : timers[r][t].cycle_duration_off;

Â  Â  Â  Â  Â  if (relays[r].mode == MODE_CYC) {
Â  Â  Â  Â  Â  Â  lcd.print((timers[r][t].selectedOption == TIMER_CYCLE_ON_DUR) ? F("ON DUR:") : F("OFF DUR:"));
Â  Â  Â  Â  Â  Â  lcd.print(F("Â  "));
Â  Â  Â  Â  Â  Â  lcd.setCursor(9, 1);
Â  Â  Â  Â  Â  Â  printCycleTime(dur.minute, dur.second);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  lcd.print(F("MODE ERRÂ  Â  Â  Â  Â  Â  Â "));
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  lcd.print(F("Â  Â  "));
Â  Â  Â  Â  Â  if (timers[r][t].setting_step != STEP_NAV_TIMER) {
Â  Â  Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  break;
Â  Â  Â  case TIMER_CYCLE_LIMIT:
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  if (relays[r].mode == MODE_CYC) {
Â  Â  Â  Â  Â  Â  lcd.print(F("LIMIT: "));
Â  Â  Â  Â  Â  Â  lcd.print(F("Â  Â  Â  Â  "));
Â  Â  Â  Â  Â  Â  lcd.setCursor(7, 1);
Â  Â  Â  Â  Â  Â  printPaddedLimit(timers[r][t].cycle_limit, true);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  lcd.print(F("MODE ERRÂ  Â  Â  Â  Â  Â  Â "));
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  if (timers[r][t].setting_step != STEP_NAV_TIMER) {
Â  Â  Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  break;
Â  Â  Â  default:
Â  Â  Â  Â  break;
Â  Â  }
Â  }
}

// 15. CÃC HÃ€M RTC
void displayRtcMainMenu() {
Â  if (!lcd_is_awake) return;

Â  lcd.setCursor(0, 0);
Â  lcd.print(F("CHON CAI DAT RTC:"));

Â  lcd.setCursor(0, 1);
Â  lcd.print(F("Â  Â  Â  Â  Â  Â  Â  Â  "));

Â  lcd.setCursor(1, 1);
Â  switch (rtcMenuOption) {
Â  Â  case RTC_MENU_TIME:
Â  Â  Â  lcd.print(F("TIME SETTING"));
Â  Â  Â  break;
Â  Â  case RTC_MENU_DATE:
Â  Â  Â  lcd.print(F("DATE SETTING"));
Â  Â  Â  break;
Â  Â  case RTC_MENU_BACK:
Â  Â  Â  lcd.print(F("BACK"));
Â  Â  Â  break;
Â  }

Â  lcd.setCursor(0, 1);
Â  lcd.print(F(">"));
Â  lcd.noCursor();
Â  lcd.noBlink();
}

void displayRtcEdit_Dynamic() {
Â  if (!lcd_is_awake) return;

Â  lcd.setCursor(5, 0);
Â  if (rtc_temp_time.hour() < 10) lcd.print(F("0"));
Â  lcd.print(rtc_temp_time.hour());
Â  lcd.print(F(":"));
Â  if (rtc_temp_time.minute() < 10) lcd.print(F("0"));
Â  lcd.print(rtc_temp_time.minute());

Â  if (rtcEditStep == RTC_EDIT_SAVE) {
Â  Â  lcd.setCursor(11, 0);
Â  Â  lcd.print(F("[LUU]"));
Â  } else if (rtcEditStep == RTC_EDIT_CANCEL) {
Â  Â  lcd.setCursor(11, 0);
Â  Â  lcd.print(F("[HUY]"));
Â  } else if (rtcEditStep == RTC_EDIT_BACK) {
Â  Â  lcd.setCursor(11, 0);
Â  Â  lcd.print(F("[BACK]"));
Â  } else {
Â  Â  lcd.setCursor(11, 0);
Â  Â  lcd.print(F("Â  Â  Â "));
Â  }

Â  lcd.setCursor(5, 1);
Â  if (rtc_temp_time.day() < 10) lcd.print(F("0"));
Â  lcd.print(rtc_temp_time.day());
Â  lcd.print(F("/"));
Â  if (rtc_temp_time.month() < 10) lcd.print(F("0"));
Â  lcd.print(rtc_temp_time.month());
Â  lcd.print(F("/"));
Â  uint16_t y = rtc_temp_time.year() % 100;
Â  if (y < 10) lcd.print(F("0"));
Â  lcd.print(y);
}

void updateRtcEdit_Cursor() {
Â  if (!lcd_is_awake) return;

Â  lcd.cursor();
Â  lcd.blink();

Â  if (rtcEditStep <= RTC_EDIT_YY) {
Â  Â  switch (rtcEditStep) {
Â  Â  Â  case RTC_EDIT_HH: lcd.setCursor(5, 0); break;
Â  Â  Â  case RTC_EDIT_MM: lcd.setCursor(8, 0); break;
Â  Â  Â  case RTC_EDIT_DD: lcd.setCursor(5, 1); break;
Â  Â  Â  case RTC_EDIT_MO: lcd.setCursor(8, 1); break;
Â  Â  Â  case RTC_EDIT_YY: lcd.setCursor(11, 1); break;
Â  Â  Â  default: break;
Â  Â  }
Â  } else {
Â  Â  lcd.setCursor(12, 0);
Â  Â  lcd.blink();
Â  }
}

// 16. HÃ€M Xá»¬ LÃ NÃšT NHáº¤N (Sá»­ dá»¥ng Cá» Ngáº¯t cho Polling)
void handleButtons() {
Â  unsigned long currentMillis = millis();

Â  auto checkButton = [&](uint8_t pin, volatile bool& flag, int index, void (*handler)(unsigned long)) {
Â  Â  if (flag) {
Â  Â  Â  int reading = digitalRead(pin);
Â  Â  Â  if (reading != lastButtonState[index]) {
Â  Â  Â  Â  if ((currentMillis - interruptEndTime) > DEBOUNCING_TIME) {
Â  Â  Â  Â  Â  if (reading == LOW) {
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // **ÄÃ¡nh thá»©c LCD khi cÃ³ click**
Â  Â  Â  Â  Â  Â  wakeLcd();
Â  Â  Â  Â  Â  Â  handler(currentMillis);
Â  Â  Â  Â  Â  Â  buttonClickProcessed = false;
Â  Â  Â  Â  Â  Â  interruptEndTime = currentMillis;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  lastButtonState[index] = reading;
Â  Â  Â  Â  Â  flag = false;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  };

Â  checkButton(BUTTON_UP_PIN, buttonUpFlag, 0, handleButtonUp);
Â  checkButton(BUTTON_DOWN_PIN, buttonDownFlag, 2, handleButtonDown);

Â  // Xá»­ lÃ½ nÃºt SELECT (Giá»¯ láº¡i logic Hold)
Â  if (buttonSelectFlag) {
Â  Â  int reading = digitalRead(BUTTON_SELECT_PIN);
Â  Â  if (reading != lastButtonState[1]) {
Â  Â  Â  if ((currentMillis - interruptEndTime) > DEBOUNCING_TIME) {
Â  Â  Â  Â  if (reading == LOW) {
Â  Â  Â  Â  Â  pressSelectStartTime = currentMillis;
Â  Â  Â  Â  Â  isHoldingSelect = false;
Â  Â  Â  Â  Â  buttonClickProcessed = false;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // **ÄÃ¡nh thá»©c LCD khi cÃ³ click**
Â  Â  Â  Â  Â  wakeLcd();
Â  Â  Â  Â  Â  if (!isHoldingSelect && !buttonClickProcessed) {
Â  Â  Â  Â  Â  Â  handleButtonSelect_Click();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  isHoldingSelect = false;
Â  Â  Â  Â  Â  buttonClickProcessed = false;
Â  Â  Â  Â  Â  interruptEndTime = currentMillis;
Â  Â  Â  Â  }
Â  Â  Â  Â  lastButtonState[1] = reading;
Â  Â  Â  Â  buttonSelectFlag = false;
Â  Â  Â  }
Â  Â  }
Â  }

Â  // Logic Hold cho SELECT (Quick Manual Toggle/Cycle Override)
Â  if (digitalRead(BUTTON_SELECT_PIN) == LOW && lcd_is_awake) {Â  // **Chá»‰ xá»­ lÃ½ Hold khi LCD Ä‘ang báº­t**
Â  Â  if (!isHoldingSelect) {
Â  Â  Â  const unsigned long NEW_HOLD_START_DELAY = 500;

Â  Â  Â  if ((currentMillis - pressSelectStartTime) >= NEW_HOLD_START_DELAY) {

Â  Â  Â  Â  // 1. Logic Quick Manual Toggle (GIá»® Láº I)
Â  Â  Â  Â  if (nav.currentState == MENU_HOME && nav.selectedIndex < NUM_RELAYS && relays[nav.selectedIndex].mode == MODE_MAN) {
Â  Â  Â  Â  Â  handleButtonSelect_Hold(false);
Â  Â  Â  Â  Â  if (buttonClickProcessed) {
Â  Â  Â  Â  Â  Â  isHoldingSelect = true;
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // 2. Logic Cycle Override (GIá»® Láº I)
Â  Â  Â  Â  if (nav.currentState == MENU_RELAY_SETTINGS) {
Â  Â  Â  Â  Â  uint8_t r_ = nav.selectedIndex;
Â  Â  Â  Â  Â  RelayMenuOption currentSetting_ = relays[r_].selectedOption;
Â  Â  Â  Â  Â  uint8_t t_ = currentSetting_ - RELAY_STATUS_OR_TIMER1;

Â  Â  Â  Â  Â  bool isEditingTimer_ = (currentSetting_ >= RELAY_STATUS_OR_TIMER1 && currentSetting_ <= RELAY_TIMER4) && (timers[r_][t_].setting_step != STEP_DONE && timers[r_][t_].setting_step != STEP_NAV_TIMER);

Â  Â  Â  Â  Â  if (isEditingTimer_) {
Â  Â  Â  Â  Â  Â  const unsigned long OVERRIDE_HOLD_TIME_LOCAL = 1500;
Â  Â  Â  Â  Â  Â  if ((currentMillis - pressSelectStartTime) >= OVERRIDE_HOLD_TIME_LOCAL) {

Â  Â  Â  Â  Â  Â  Â  handleButtonSelect_Hold(true);
Â  Â  Â  Â  Â  Â  Â  if (buttonClickProcessed) {
Â  Â  Â  Â  Â  Â  Â  Â  isHoldingSelect = true;
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  } else {
Â  Â  isHoldingSelect = false;
Â  }
}


// 17. HÃ€M HÃ€NH Äá»˜NG Cá»¦A NÃšT NHáº¤N
void handleButtonUp(unsigned long currentMillis) {
Â  if (!lcd_is_awake) return;

Â  lastActionTime = currentMillis;
Â  needsDisplayUpdate = true;
Â  uint16_t step = 1;

Â  uint8_t r, t;
Â  RelayMenuOption selected;

Â  if (nav.currentState == MENU_RELAY_SETTINGS) {
Â  Â  r = nav.selectedIndex;
Â  Â  selected = relays[r].selectedOption;
Â  Â  if (selected >= RELAY_STATUS_OR_TIMER1 && selected <= RELAY_TIMER4) {
Â  Â  Â  t = selected - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  if (timers[r][t].setting_step != STEP_DONE && timers[r][t].setting_step != STEP_NAV_TIMER) {
Â  Â  Â  Â  if (timers[r][t].mode == 1 && timers[r][t].cycle_last_state_change_time_seconds != 0) {
Â  Â  Â  Â  Â  showAlert(F("TIMER IS ACTIVE!"));
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  }

Â  switch (nav.currentState) {
Â  Â  case MENU_HOME:
Â  Â  Â  {
Â  Â  Â  Â  const uint8_t HOME_MAX_INDEX = NUM_RELAYS;
Â  Â  Â  Â  if (nav.selectedIndex <= 0) {
Â  Â  Â  Â  Â  nav.selectedIndex = HOME_MAX_INDEX;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  nav.selectedIndex--;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  currentDisplayedMenu = (MenuState)0xFF;
Â  Â  Â  lastSecond = 60;
Â  Â  Â  lastDay = 32;
Â  Â  Â  break;

Â  Â  case MENU_RTC_MAIN_MENU:
Â  Â  Â  rtcMenuOption = (RtcMenuOption)((rtcMenuOption == RTC_MENU_TIME) ? RTC_MENU_BACK : (uint8_t)rtcMenuOption - 1);
Â  Â  Â  break;

Â  Â  case MENU_RELAY_SETTINGS:
Â  Â  Â  r = nav.selectedIndex;
Â  Â  Â  selected = relays[r].selectedOption;

Â  Â  Â  if (selected >= RELAY_STATUS_OR_TIMER1 && selected <= RELAY_TIMER4 && relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  t = selected - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  Â  SettingStep currentStep = timers[r][t].setting_step;

Â  Â  Â  Â  if (currentStep == STEP_DONE) {
Â  Â  Â  Â  Â  navigateRelaySettings(r, true);
Â  Â  Â  Â  } else if (currentStep == STEP_NAV_TIMER) {
Â  Â  Â  Â  Â  navigateTimerMenu(r, t, true);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  navigateSettingValue(r, t, true, step);
Â  Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  Â  Â  lastSettingsChangeTime = currentMillis;
Â  Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  navigateRelaySettings(r, true);
Â  Â  Â  }
Â  Â  Â  break;

Â  Â  case MENU_SAVE_PROMPT:
Â  Â  Â  navigateSavePrompt(true);
Â  Â  Â  break;
Â  Â  case MENU_RTC_EDIT:
Â  Â  Â  navigateRtcEdit(true, step);
Â  Â  Â  break;

Â  Â  default:
Â  Â  Â  needsDisplayUpdate = false;
Â  Â  Â  break;
Â  }
}

void handleButtonDown(unsigned long currentMillis) {
Â  if (!lcd_is_awake) return;

Â  lastActionTime = currentMillis;
Â  needsDisplayUpdate = true;
Â  uint16_t step = 1;

Â  uint8_t r, t;
Â  RelayMenuOption selected;

Â  if (nav.currentState == MENU_RELAY_SETTINGS) {
Â  Â  r = nav.selectedIndex;
Â  Â  selected = relays[r].selectedOption;
Â  Â  if (selected >= RELAY_STATUS_OR_TIMER1 && selected <= RELAY_TIMER4) {
Â  Â  Â  t = selected - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  if (timers[r][t].setting_step != STEP_DONE && timers[r][t].setting_step != STEP_NAV_TIMER) {
Â  Â  Â  Â  if (timers[r][t].mode == 1 && timers[r][t].cycle_last_state_change_time_seconds != 0) {
Â  Â  Â  Â  Â  showAlert(F("TIMER IS ACTIVE!"));
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  }

Â  switch (nav.currentState) {
Â  Â  case MENU_HOME:
Â  Â  Â  {
Â  Â  Â  Â  const uint8_t HOME_MAX_INDEX_DOWN = NUM_RELAYS;
Â  Â  Â  Â  nav.selectedIndex = (nav.selectedIndex + 1) % (HOME_MAX_INDEX_DOWN + 1);
Â  Â  Â  }
Â  Â  Â  currentDisplayedMenu = (MenuState)0xFF;
Â  Â  Â  lastSecond = 60;
Â  Â  Â  lastDay = 32;
Â  Â  Â  break;

Â  Â  case MENU_RTC_MAIN_MENU:
Â  Â  Â  rtcMenuOption = (RtcMenuOption)((rtcMenuOption == RTC_MENU_BACK) ? RTC_MENU_TIME : (uint8_t)rtcMenuOption + 1);
Â  Â  Â  break;

Â  Â  case MENU_RELAY_SETTINGS:
Â  Â  Â  r = nav.selectedIndex;
Â  Â  Â  selected = relays[r].selectedOption;

Â  Â  Â  if (selected >= RELAY_STATUS_OR_TIMER1 && selected <= RELAY_TIMER4 && relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  t = selected - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  Â  SettingStep currentStep = timers[r][t].setting_step;

Â  Â  Â  Â  if (currentStep == STEP_DONE) {
Â  Â  Â  Â  Â  navigateRelaySettings(r, false);
Â  Â  Â  Â  } else if (currentStep == STEP_NAV_TIMER) {
Â  Â  Â  Â  Â  navigateTimerMenu(r, t, false);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  navigateSettingValue(r, t, false, step);
Â  Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  Â  Â  lastSettingsChangeTime = currentMillis;
Â  Â  Â  Â  Â  updateCursorPos(r, t);
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  navigateRelaySettings(r, false);
Â  Â  Â  }
Â  Â  Â  break;

Â  Â  case MENU_SAVE_PROMPT:
Â  Â  Â  navigateSavePrompt(false);
Â  Â  Â  break;
Â  Â  case MENU_RTC_EDIT:
Â  Â  Â  navigateRtcEdit(false, step);
Â  Â  Â  break;

Â  Â  default:
Â  Â  Â  needsDisplayUpdate = false;
Â  Â  Â  break;
Â  }
}

void handleButtonSelect_Click() {
Â  if (!lcd_is_awake) return;

Â  lastActionTime = millis();
Â  needsDisplayUpdate = true;
Â  uint8_t r, t;
Â  MenuState s = nav.currentState;

Â  switch (s) {
Â  Â  case MENU_HOME:
Â  Â  Â  if (nav.selectedIndex == NUM_RELAYS) {
Â  Â  Â  Â  nav.currentState = MENU_RTC_MAIN_MENU;
Â  Â  Â  Â  rtcMenuOption = RTC_MENU_TIME;
Â  Â  Â  Â  needsDisplayUpdate = true;
Â  Â  Â  } else {
Â  Â  Â  Â  nav.currentState = MENU_RELAY_SETTINGS;
Â  Â  Â  Â  relays[nav.selectedIndex].selectedOption = RELAY_BACK;
Â  Â  Â  }
Â  Â  Â  break;

Â  Â  case MENU_RTC_MAIN_MENU:
Â  Â  Â  if (rtcMenuOption == RTC_MENU_TIME) {
Â  Â  Â  Â  nav.currentState = MENU_RTC_EDIT;
Â  Â  Â  Â  rtcEditStep = RTC_EDIT_HH;
Â  Â  Â  Â  now = RTC.now();
Â  Â  Â  Â  rtc_temp_time = now;
Â  Â  Â  } else if (rtcMenuOption == RTC_MENU_DATE) {
Â  Â  Â  Â  nav.currentState = MENU_RTC_EDIT;
Â  Â  Â  Â  rtcEditStep = RTC_EDIT_DD;
Â  Â  Â  Â  now = RTC.now();
Â  Â  Â  Â  rtc_temp_time = now;
Â  Â  Â  } else {
Â  Â  Â  Â  nav.currentState = MENU_HOME;
Â  Â  Â  Â  nav.selectedIndex = 0;
Â  Â  Â  }
Â  Â  Â  needsDisplayUpdate = true;
Â  Â  Â  break;

Â  Â  case MENU_RELAY_SETTINGS:
Â  Â  Â  r = nav.selectedIndex;
Â  Â  Â  if (relays[r].selectedOption >= RELAY_STATUS_OR_TIMER1 && relays[r].selectedOption <= RELAY_TIMER4 && relays[r].mode != MODE_MAN) {
Â  Â  Â  Â  t = relays[r].selectedOption - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  Â  if (timers[r][t].setting_step != STEP_DONE) {
Â  Â  Â  Â  Â  selectTimerSettings(r, t);
Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  selectRelaySettings(r);
Â  Â  Â  break;
Â  Â  case MENU_RTC_EDIT:
Â  Â  Â  selectRtcEdit();
Â  Â  Â  break;
Â  Â  case MENU_SAVE_PROMPT:
Â  Â  Â  selectSavePrompt();
Â  Â  Â  break;
Â  Â  default:
Â  Â  Â  needsDisplayUpdate = false;
Â  Â  Â  break;
Â  }
}

void handleButtonSelect_Hold(bool checkCycleReset) {
Â  if (!lcd_is_awake) return;

Â  unsigned long currentMillis = millis();
Â  lastActionTime = currentMillis;
Â  needsDisplayUpdate = true;
Â  MenuState s = nav.currentState;

Â  uint8_t r = nav.selectedIndex;
Â  RelayMenuOption currentSetting = relays[r].selectedOption;
Â  uint8_t t = 0;

Â  const unsigned long NEW_HOLD_START_DELAY = 500;

Â  // 1. Quick Manual Toggle (GIá»® Láº I)
Â  if (s == MENU_HOME) {
Â  Â  if ((currentMillis - pressSelectStartTime) >= NEW_HOLD_START_DELAY && !isHoldingSelect) {
Â  Â  Â  if (relays[r].mode == MODE_MAN) {
Â  Â  Â  Â  relays[r].status = 1 - relays[r].status;
Â  Â  Â  Â  updateRelayStatusInEeprom();

Â  Â  Â  Â  const __FlashStringHelper* statusMsg = (relays[r].status == 1) ? F("ON") : F("OFF");
Â  Â  Â  Â  char alertBuffer[16];
Â  Â  Â  Â  // Sá»­ dá»¥ng snprintf_P an toÃ n, sau Ä‘Ã³ truyá»n káº¿t quáº£ (chuá»—i RAM) vÃ o showAlertRam
Â  Â  Â  Â  snprintf_P(alertBuffer, sizeof(alertBuffer), (const char*)F("R%d %S!"), r + 1, statusMsg);
Â  Â  Â  Â  showAlertRam(alertBuffer);Â  // **Sá»¬A Lá»–I: Gá»i hÃ m showAlertRam**

Â  Â  Â  Â  isHoldingSelect = true;
Â  Â  Â  Â  buttonClickProcessed = true;
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  }
Â  }

Â  // 2. Cycle Override (GIá»® Láº I)
Â  if (s == MENU_RELAY_SETTINGS) {
Â  Â  if (currentSetting >= RELAY_STATUS_OR_TIMER1 && currentSetting <= RELAY_TIMER4) {
Â  Â  Â  t = currentSetting - RELAY_STATUS_OR_TIMER1;
Â  Â  Â  if (timers[r][t].setting_step != STEP_DONE && timers[r][t].setting_step != STEP_NAV_TIMER) {
Â  Â  Â  Â  bool checkTimerActive = timers[r][t].mode == 1 && timers[r][t].cycle_last_state_change_time_seconds != 0;

Â  Â  Â  Â  if (checkTimerActive) {
Â  Â  Â  Â  Â  const unsigned long OVERRIDE_HOLD_TIME_LOCAL = 1500;
Â  Â  Â  Â  Â  if ((currentMillis - pressSelectStartTime) >= OVERRIDE_HOLD_TIME_LOCAL) {
Â  Â  Â  Â  Â  Â  showAlert((const __FlashStringHelper*)MSG_OVERRIDE_OK);
Â  Â  Â  Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = currentTimeSeconds;
Â  Â  Â  Â  Â  Â  timers[r][t].cycle_is_on = true;
Â  Â  Â  Â  Â  Â  updateCycleResumeStateInEeprom(r, t);
Â  Â  Â  Â  Â  Â  isHoldingSelect = true;
Â  Â  Â  Â  Â  Â  buttonClickProcessed = true;
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  }
}

void navigateRelaySettings(uint8_t r, bool isUp) {
Â  uint8_t max_option_index = 7;

Â  RelayMenuOption current = relays[r].selectedOption;
Â  RelayMenuOption next_option = current;
Â  RelayMode mode = relays[r].mode;

Â  if (isUp) {
Â  Â  if (current == RELAY_BACK) {
Â  Â  Â  next_option = (RelayMenuOption)max_option_index;
Â  Â  } else {
Â  Â  Â  next_option = (RelayMenuOption)(current - 1);
Â  Â  }
Â  } else {
Â  Â  if (current == (RelayMenuOption)max_option_index) {
Â  Â  Â  next_option = RELAY_BACK;
Â  Â  } else {
Â  Â  Â  next_option = (RelayMenuOption)(current + 1);
Â  Â  }
Â  }

Â  if (mode == MODE_MAN) {
Â  Â  if (isUp) {
Â  Â  Â  if (next_option >= RELAY_TIMER2 && next_option <= RELAY_TIMER4) {
Â  Â  Â  Â  next_option = RELAY_STATUS_OR_TIMER1;
Â  Â  Â  } else if (current == RELAY_SENSOR_GATE && next_option == RELAY_TIMER4) {
Â  Â  Â  Â  next_option = RELAY_STATUS_OR_TIMER1;
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  if (next_option >= RELAY_TIMER2 && next_option <= RELAY_TIMER4) {
Â  Â  Â  Â  next_option = RELAY_SENSOR_GATE;
Â  Â  Â  } else if (current == RELAY_STATUS_OR_TIMER1 && next_option == RELAY_TIMER2) {
Â  Â  Â  Â  next_option = RELAY_SENSOR_GATE;
Â  Â  Â  }
Â  Â  }
Â  }

Â  relays[r].selectedOption = next_option;
}


void navigateSettingValue(uint8_t r, uint8_t t, bool isUp, uint16_t step) {
Â  (void)step;
Â  TimerMenuOption selected = timers[r][t].selectedOption;
Â  SettingStep currentStep = timers[r][t].setting_step;

Â  switch (selected) {
Â  Â  case TIMER_ON_TIME:
Â  Â  case TIMER_OFF_TIME:
Â  Â  Â  updateTimeValue(r, t, (currentStep == STEP_HH_OR_VALUE), isUp, 1);
Â  Â  Â  break;
Â  Â  case TIMER_CYCLE_ON_DUR:
Â  Â  case TIMER_CYCLE_OFF_DUR:
Â  Â  Â  updateDurationValue(r, t, (currentStep == STEP_HH_OR_VALUE), isUp, 1);
Â  Â  Â  break;
Â  Â  case TIMER_CYCLE_LIMIT:
Â  Â  Â  updateCountValue(r, t, isUp, 1);
Â  Â  Â  break;
Â  Â  case TIMER_DOW_SETTING:
Â  Â  Â  if (currentStep != STEP_NAV_TIMER) {
Â  Â  Â  Â  uint8_t max_cursor = 10;
Â  Â  Â  Â  if (isUp) {
Â  Â  Â  Â  Â  dow_cursor[r][t] = (dow_cursor[r][t] == 0) ? max_cursor : dow_cursor[r][t] - 1;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  dow_cursor[r][t] = (dow_cursor[r][t] == max_cursor) ? 0 : dow_cursor[r][t] + 1;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case TIMER_RESET_COUNT:
Â  Â  Â  break;
Â  Â  default:
Â  Â  Â  return;
Â  }
}

void navigateTimerMenu(uint8_t r, uint8_t t, bool isUp) {
Â  TimerMenuOption current = timers[r][t].selectedOption;
Â  TimerMenuOption next_option;

Â  TimerMenuOption max_option = TIMER_RESET_COUNT;

Â  if (isUp) {
Â  Â  next_option = (current == TIMER_BACK) ? max_option : (TimerMenuOption)((uint8_t)current - 1);
Â  } else {
Â  Â  next_option = (current == max_option) ? TIMER_BACK : (TimerMenuOption)((uint8_t)current + 1);
Â  }

Â  if (relays[r].mode == MODE_AUT) {
Â  Â  if (next_option >= TIMER_CYCLE_ON_DUR && next_option <= TIMER_RESET_COUNT) {
Â  Â  Â  if (isUp) {
Â  Â  Â  Â  next_option = TIMER_OFF_TIME;
Â  Â  Â  } else {
Â  Â  Â  Â  next_option = TIMER_BACK;
Â  Â  Â  }
Â  Â  }
Â  }

Â  timers[r][t].selectedOption = next_option;
}


void navigateSavePrompt(bool isUp) {
Â  (void)isUp;
Â  nav.selectedIndex = 1 - nav.selectedIndex;
}

void navigateRtcEdit(bool isUp, uint16_t step) {
Â  (void)step;

Â  uint16_t y = rtc_temp_time.year();
Â  uint8_t m = rtc_temp_time.month();
Â  uint8_t d = rtc_temp_time.day();
Â  uint8_t h = rtc_temp_time.hour();
Â  uint8_t min = rtc_temp_time.minute();

Â  uint8_t daysInMonth[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
Â  if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0)) {
Â  Â  daysInMonth[2] = 29;
Â  }

Â  uint16_t actual_step = 1;

Â  switch (rtcEditStep) {
Â  Â  case RTC_EDIT_HH:
Â  Â  Â  h = isUp ? (h + actual_step) % 24 : (h < actual_step ? 24 - (actual_step - h) : h - actual_step);
Â  Â  Â  break;
Â  Â  case RTC_EDIT_MM:
Â  Â  Â  min = isUp ? (min + actual_step > 59 ? (min + actual_step) - 60 : min + actual_step) : (min < actual_step ? (60 - (actual_step - min)) : (min - actual_step));
Â  Â  Â  break;
Â  Â  case RTC_EDIT_DD:
Â  Â  Â  {
Â  Â  Â  Â  uint8_t max_days = daysInMonth[m];

Â  Â  Â  Â  if (isUp) {
Â  Â  Â  Â  Â  d = ((d + actual_step - 1) % max_days) + 1;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  d = ((d - 1 + max_days - actual_step) % max_days) + 1;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RTC_EDIT_MO:
Â  Â  Â  {
Â  Â  Â  Â  if (isUp) {
Â  Â  Â  Â  Â  m = ((m + actual_step - 1) % 12) + 1;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  m = ((m - 1 + 12 - actual_step) % 12) + 1;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RTC_EDIT_YY:
Â  Â  Â  {
Â  Â  Â  Â  uint16_t y_short = y % 100;
Â  Â  Â  Â  uint16_t step_short = actual_step;

Â  Â  Â  Â  if (isUp) {
Â  Â  Â  Â  Â  y_short = (y_short + step_short) % 100;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  if (y_short < step_short) {
Â  Â  Â  Â  Â  Â  y_short = 100 + (y_short - step_short);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  y_short = y_short - step_short;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  y = 2000 + y_short;
Â  Â  Â  Â  if (y < 2000) y = 2000;
Â  Â  Â  Â  if (y > 2099) y = 2099;
Â  Â  Â  }
Â  Â  Â  break;
Â  Â  case RTC_EDIT_SAVE:
Â  Â  case RTC_EDIT_CANCEL:
Â  Â  case RTC_EDIT_BACK:
Â  Â  Â  if (isUp) {
Â  Â  Â  Â  if (rtcEditStep == RTC_EDIT_SAVE) {
Â  Â  Â  Â  Â  rtcEditStep = RTC_EDIT_BACK;
Â  Â  Â  Â  } else if (rtcEditStep == RTC_EDIT_BACK) {
Â  Â  Â  Â  Â  rtcEditStep = RTC_EDIT_CANCEL;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  rtcEditStep = RTC_EDIT_SAVE;
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  if (rtcEditStep == RTC_EDIT_SAVE) {
Â  Â  Â  Â  Â  rtcEditStep = RTC_EDIT_CANCEL;
Â  Â  Â  Â  } else if (rtcEditStep == RTC_EDIT_CANCEL) {
Â  Â  Â  Â  Â  rtcEditStep = RTC_EDIT_BACK;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  rtcEditStep = RTC_EDIT_SAVE;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  break;
Â  }

Â  if (rtcEditStep == RTC_EDIT_MO || rtcEditStep == RTC_EDIT_YY) {
Â  Â  if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0)) {
Â  Â  Â  daysInMonth[2] = 29;
Â  Â  } else {
Â  Â  Â  daysInMonth[2] = 28;
Â  Â  }
Â  }

Â  if (m > 0 && d > daysInMonth[m]) {
Â  Â  d = daysInMonth[m];
Â  }

Â  if (m == 0) m = 1;

Â  rtc_temp_time = DateTime(y, m, d, h, min, 0);
}

void selectRtcEdit() {
Â  if (rtcEditStep == RTC_EDIT_SAVE) {
Â  Â  rtc_temp_time = DateTime(rtc_temp_time.year(), rtc_temp_time.month(), rtc_temp_time.day(),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â rtc_temp_time.hour(), rtc_temp_time.minute(), 0);
Â  Â  RTC.adjust(rtc_temp_time);
Â  Â  now = RTC.now();
Â  Â  nav.currentState = MENU_HOME;
Â  Â  nav.selectedIndex = 0;
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  } else if (rtcEditStep == RTC_EDIT_CANCEL) {
Â  Â  nav.currentState = MENU_HOME;
Â  Â  nav.selectedIndex = 0;
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  } else if (rtcEditStep == RTC_EDIT_BACK) {
Â  Â  nav.currentState = MENU_HOME;
Â  Â  nav.selectedIndex = 0;
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  } else {
Â  Â  uint8_t nextStep = (uint8_t)rtcEditStep + 1;

Â  Â  if (rtcMenuOption == RTC_MENU_TIME) {
Â  Â  Â  if (rtcEditStep == RTC_EDIT_HH) nextStep = RTC_EDIT_MM;
Â  Â  Â  else if (rtcEditStep == RTC_EDIT_MM) nextStep = RTC_EDIT_SAVE;
Â  Â  Â  else nextStep = RTC_EDIT_HH;
Â  Â  } else if (rtcMenuOption == RTC_MENU_DATE) {
Â  Â  Â  if (rtcEditStep == RTC_EDIT_DD) nextStep = RTC_EDIT_MO;
Â  Â  Â  else if (rtcEditStep == RTC_EDIT_MO) nextStep = RTC_EDIT_YY;
Â  Â  Â  else if (rtcEditStep == RTC_EDIT_YY) nextStep = RTC_EDIT_SAVE;
Â  Â  Â  else nextStep = RTC_EDIT_DD;
Â  Â  } else {
Â  Â  Â  if (nextStep > (uint8_t)RTC_EDIT_BACK) {
Â  Â  Â  Â  nextStep = (uint8_t)RTC_EDIT_HH;
Â  Â  Â  }
Â  Â  }

Â  Â  rtcEditStep = (RtcEditStep)nextStep;
Â  }
}


void selectRelaySettings(uint8_t r) {
Â  if (relays[r].selectedOption == RELAY_BACK) {
Â  Â  nav.currentState = MENU_HOME;
Â  Â  nav.selectedIndex = 0;
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  } else if (relays[r].selectedOption == RELAY_MODE) {
Â  Â  relays[r].mode = (RelayMode)((relays[r].mode + 1) % 3);
Â  Â  settings_changed = true;
Â  Â  lastSettingsChangeTime = millis();
Â  Â  relays[r].status = 0;
Â  Â  relays[r].selectedOption = RELAY_STATUS_OR_TIMER1;
Â  } else if (relays[r].selectedOption == RELAY_STATUS_OR_TIMER1 && relays[r].mode == MODE_MAN) {
Â  Â  relays[r].status = 1 - relays[r].status;
Â  Â  updateRelayStatusInEeprom();
Â  } else if (relays[r].selectedOption == RELAY_SENSOR_GATE) {
Â  Â  relays[r].sensor_gate_enabled = !relays[r].sensor_gate_enabled;
Â  Â  settings_changed = true;
Â  Â  lastSettingsChangeTime = millis();
Â  } else if (relays[r].selectedOption == RELAY_SENSOR_LOGIC) {
Â  Â  relays[r].sensor_logic = (SensorLogic)(1 - relays[r].sensor_logic);
Â  Â  settings_changed = true;
Â  Â  lastSettingsChangeTime = millis();
Â  } else if (relays[r].selectedOption >= RELAY_STATUS_OR_TIMER1 && relays[r].selectedOption <= RELAY_TIMER4 && relays[r].mode != MODE_MAN) {
Â  Â  uint8_t t = relays[r].selectedOption - RELAY_STATUS_OR_TIMER1;
Â  Â  timers[r][t].setting_step = STEP_NAV_TIMER;
Â  Â  timers[r][t].selectedOption = TIMER_MODE;

Â  Â  currentDisplayedMenu = (MenuState)0xFF;
Â  Â  updateDisplay();
Â  }
}

void selectTimerSettings(uint8_t r, uint8_t t) {

Â  if (timers[r][t].selectedOption == TIMER_BACK) {
Â  Â  timers[r][t].setting_step = STEP_DONE;
Â  Â  lcd.noCursor();
Â  Â  lcd.noBlink();
Â  Â  relays[r].selectedOption = (RelayMenuOption)(t + RELAY_STATUS_OR_TIMER1);

Â  } else if (timers[r][t].selectedOption == TIMER_MODE) {
Â  Â  timers[r][t].mode = 1 - timers[r][t].mode;
Â  Â  if (timers[r][t].mode == 0) {
Â  Â  Â  timers[r][t].cycle_count = 0;
Â  Â  Â  cycleCountBuffer[r][t] = 0;
Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = 0;
Â  Â  } else {
Â  Â  Â  if (relays[r].mode == MODE_AUT || relays[r].mode == MODE_CYC) {
Â  Â  Â  Â  if (timers[r][t].cached_time_on_sec == timers[r][t].cached_time_off_sec) {
Â  Â  Â  Â  Â  timers[r][t].mode = 0;
Â  Â  Â  Â  Â  showAlert((const __FlashStringHelper*)MSG_ON_OFF_ERROR);
Â  Â  Â  Â  Â  needsDisplayUpdate = true;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  Â  settings_changed = true;
Â  Â  lastSettingsChangeTime = millis();

Â  } else if (timers[r][t].selectedOption == TIMER_DOW_SETTING) {
Â  Â  if (timers[r][t].setting_step == STEP_NAV_TIMER) {
Â  Â  Â  timers[r][t].setting_step = STEP_HH_OR_VALUE;
Â  Â  Â  dow_cursor[r][t] = 0;
Â  Â  Â  currentDisplayedMenu = (MenuState)0xFF;
Â  Â  } else {

Â  Â  Â  uint8_t cursor = dow_cursor[r][t];

Â  Â  Â  if (cursor < 7) {
Â  Â  Â  Â  timers[r][t].dow_mask ^= (1 << cursor);
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  } else if (cursor == 7) {
Â  Â  Â  Â  timers[r][t].dow_mask = 0b01111111;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  } else if (cursor == 8) {
Â  Â  Â  Â  timers[r][t].dow_mask = 0b00000000;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  } else if (cursor == 9) {
Â  Â  Â  Â  timers[r][t].dow_mask = 0b00111111;
Â  Â  Â  Â  settings_changed = true;
Â  Â  Â  } else if (cursor == 10) {
Â  Â  Â  Â  timers[r][t].setting_step = STEP_NAV_TIMER;
Â  Â  Â  Â  lcd.noCursor();
Â  Â  Â  Â  lcd.noBlink();
Â  Â  Â  }

Â  Â  Â  if (settings_changed) {
Â  Â  Â  Â  lastSettingsChangeTime = millis();
Â  Â  Â  }
Â  Â  }

Â  } else if (timers[r][t].selectedOption == TIMER_RESET_COUNT) {
Â  Â  if (relays[r].mode == MODE_CYC) {
Â  Â  Â  timers[r][t].cycle_count = 0;
Â  Â  Â  cycleCountBuffer[r][t] = 0;
Â  Â  Â  cycle_count_changed = true;

Â  Â  Â  timers[r][t].cycle_last_state_change_time_seconds = 0;
Â  Â  Â  timers[r][t].cycle_is_on = false;
Â  Â  Â  updateCycleResumeStateInEeprom(r, t);

Â  Â  Â  showAlert((const __FlashStringHelper*)MSG_COUNT_RESET_OK);
Â  Â  Â  needsDisplayUpdate = true;
Â  Â  }
Â  } else if (timers[r][t].selectedOption >= TIMER_ON_TIME) {

Â  Â  if (timers[r][t].selectedOption == TIMER_ON_TIME || timers[r][t].selectedOption == TIMER_OFF_TIME) {
Â  Â  Â  if (relays[r].mode != MODE_AUT && relays[r].mode != MODE_CYC) return;
Â  Â  } else {
Â  Â  Â  if (relays[r].mode != MODE_CYC) return;
Â  Â  }


Â  Â  if (timers[r][t].setting_step == STEP_NAV_TIMER) {
Â  Â  Â  timers[r][t].setting_step = STEP_HH_OR_VALUE;

Â  Â  } else if (timers[r][t].setting_step == STEP_HH_OR_VALUE) {
Â  Â  Â  if (timers[r][t].selectedOption == TIMER_ON_TIME || timers[r][t].selectedOption == TIMER_OFF_TIME || (timers[r][t].selectedOption >= TIMER_CYCLE_ON_DUR && timers[r][t].selectedOption <= TIMER_CYCLE_OFF_DUR)) {
Â  Â  Â  Â  timers[r][t].setting_step = STEP_MM;
Â  Â  Â  } else {
Â  Â  Â  Â  timers[r][t].setting_step = STEP_NAV_TIMER;
Â  Â  Â  }

Â  Â  } else if (timers[r][t].setting_step == STEP_MM) {
Â  Â  Â  timers[r][t].setting_step = STEP_NAV_TIMER;
Â  Â  }

Â  Â  if (timers[r][t].setting_step == STEP_NAV_TIMER) {
Â  Â  Â  lcd.noCursor();
Â  Â  Â  lcd.noBlink();
Â  Â  Â  settings_changed = true;
Â  Â  Â  lastSettingsChangeTime = millis();
Â  Â  }
Â  }
}


void selectSavePrompt() {
Â  if (nav.selectedIndex == 0) {
Â  Â  saveSettings();
Â  Â  settings_changed = false;
Â  } else {
Â  Â  loadSettings();
Â  Â  settings_changed = false;
Â  }
Â  nav.currentState = MENU_HOME;
Â  nav.selectedIndex = 0;
Â  lcd.noCursor();
Â  lcd.noBlink();
}
